package co.uk.offerland.job_track.infrastructure.converter;import java.time.Instant;import java.util.Comparator;import java.util.List;import java.util.Optional;import java.util.UUID;import co.uk.offerland.job_track.application.dto.phase.InterviewNoteResponse;import co.uk.offerland.job_track.application.dto.user.*;import co.uk.offerland.job_track.domain.entity.ContactPerson;import co.uk.offerland.job_track.domain.entity.PhaseStatus;import co.uk.offerland.job_track.domain.entity.nosql.*;import co.uk.offerland.job_track.infrastructure.exception.JobNotFoundException;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import co.uk.offerland.job_track.application.dto.phase.PhaseResponse;import static java.util.Optional.ofNullable;@Componentpublic class JobConverter {    public Job toEntity(CreateJobRequest request, Instant now) {        var newJob = new Job();        newJob.initializeAvailablePhases();        newJob.setCompany(request.getCompany());        newJob.setJobUrl(request.getJobUrl());        newJob.setTitle(request.getTitle());        newJob.setLocation(request.getLocation());        newJob.setCompanyLogo(request.getCompanyLogo());        newJob.setJobSalary(request.getJobSalary());        newJob.setDesiredSalary(request.getDesiredSalary());        newJob.setCurrency(request.getCurrency());        newJob.setAddType(request.getAddType());        newJob.setDescription(request.getDescription());        newJob.setCreatedAt(now);        newJob.setUpdatedAt(now);        return newJob;    }    public ListJobs toJobsResponse(User user) {        return new ListJobs(                user.getJobs().stream()                        .map(this::toResponse)                        .toList(),                new InterviewStats(                        user.getInterviewStat().getSavedCount(),                        user.getInterviewStat().getAppliedCount(),                        user.getInterviewStat().getInterviewCount(),                        user.getInterviewStat().getRejectedCount(),                        user.getInterviewStat().getAcceptedCount(),                        new DailyProgress(                                DailyProgressEntity.MAX_DAILY_CV,                                user.getInterviewStat().getDailyProgress().getCurrentCVAmount()                        )                )        );    }    public CreateJobResponse toResponse(Job job) {        var result = new CreateJobResponse();        result.setId(job.getJobId().toString());        result.setCompany(job.getCompany());        result.setTitle(job.getTitle());        result.setLocation(job.getLocation());        result.setJobUrl(job.getJobUrl());        result.setJobSalary(job.getJobSalary());        result.setCurrency(toCurrencySign(job.getCurrency()));        result.setAddType(job.getAddType());        result.setDescription(job.getDescription());        result.setNotes(                new InterviewNoteResponse(ofNullable(job.getNotes()).map(InterviewNote::getNotes).orElse("")));        result.setCompanyLogo(job.getCompanyLogo());        result.setWishlistDate(job.getCreatedAt().toString());        List<PhaseResponse> phases = job.getPhases().stream()                .sorted(Comparator.comparingInt(Phase::getOrderIndex))                .map(this::toPhaseResponse)                .toList();        result.setPhases(phases);        result.setAvailablePhases(job.getAvailablePhases());        result.setCurrentPhase(job.getPhases().stream()                .filter(e -> e.getStatus() == PhaseStatus.IN_PROGRESS)                .map(this::toPhaseResponse)                .findFirst()                .orElse(phases.getLast()));        if (job.getContactPerson() != null) {            result.setContactPerson(createContactResponse(job.getContactPerson()));        }        return result;    }    private String toCurrencySign(String currency) {        if (currency == null) {            return "$";        }        return switch (currency) {            case "EUR" -> "€";            case "USD" -> "$";            case "GBP" -> "£";            default -> "$";        };    }    private ContactPersonResponse createContactResponse(ContactPerson contactPerson) {        ContactPersonResponse result = new ContactPersonResponse();        result.setFullName(contactPerson.getFullName());        result.setEmail(contactPerson.getEmail());        result.setPhone(contactPerson.getPhone());        result.setLinkedin(contactPerson.getLinkedin());        return result;    }    public PhaseResponse toPhaseResponse(Phase jobPhaseEntity) {        var result = new PhaseResponse();        result.setLastUpdateDate(jobPhaseEntity.getLastUpdatedDate());        result.setOrderIndex(jobPhaseEntity.getOrderIndex());        result.setStatus(jobPhaseEntity.getStatus());        result.setName(jobPhaseEntity.getPhaseName());        result.setId(jobPhaseEntity.getJobPhaseId());        result.setSubStatus(jobPhaseEntity.getSubStatus().getLabel());        result.setInterviewScheduleTime(jobPhaseEntity.getInterviewScheduleTime());        return result;    }    public ContactPersonResponse toContactPersonResponse(User user, UUID jobId) {        return user.getJobs().stream()                .filter(job -> job.getJobId().equals(jobId))                .findAny()                .map(job -> {                    ContactPerson contactPerson = job.getContactPerson();                    if (contactPerson == null) {                        return null;                    }                    ContactPersonResponse result = new ContactPersonResponse();                    result.setFullName(contactPerson.getFullName());                    result.setEmail(contactPerson.getEmail());                    result.setPhone(contactPerson.getPhone());                    result.setLinkedin(contactPerson.getLinkedin());                    result.setCommunicationChannel(contactPerson.getCommunicationChannel());                    return result;                })                .orElseThrow(() -> new JobNotFoundException(user.getUserId().toString(), jobId.toString()));    }}