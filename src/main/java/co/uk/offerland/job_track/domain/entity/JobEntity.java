package co.uk.offerland.job_track.domain.entity;import java.time.Instant;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.UUID;//import org.springframework.data.relational.core.mapping.Table;import org.hibernate.annotations.UuidGenerator;import org.springframework.data.annotation.CreatedDate;import org.springframework.data.annotation.LastModifiedDate;import org.springframework.data.jpa.domain.support.AuditingEntityListener;import jakarta.persistence.CascadeType;import jakarta.persistence.CollectionTable;import jakarta.persistence.Column;import jakarta.persistence.ElementCollection;import jakarta.persistence.Entity;import jakarta.persistence.EntityListeners;import jakarta.persistence.FetchType;import jakarta.persistence.GeneratedValue;import jakarta.persistence.Id;import jakarta.persistence.JoinColumn;import jakarta.persistence.ManyToOne;import jakarta.persistence.OneToMany;import jakarta.persistence.OneToOne;import jakarta.persistence.OrderBy;//import jakarta.persistence.Table;import jakarta.persistence.Table;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.ToString;@Data@EqualsAndHashCode@Entity@Table(name = "jobs")@org.springframework.data.relational.core.mapping.Table(name = "jobs")@ToString(exclude = {"phases"})@EntityListeners(AuditingEntityListener.class)public class JobEntity {    @Id    @GeneratedValue    @UuidGenerator(style = UuidGenerator.Style.TIME)    @Column(name = "id", nullable = false, updatable = false)    private UUID id;    @JoinColumn(name = "company")    private String company;    @JoinColumn(name = "title")    private String title;    @JoinColumn(name = "location")    private String location;    @JoinColumn(name = "link")    private String link;    @JoinColumn(name = "company_logo")    private String companyLogo;    @JoinColumn(name = "notes")    private String notes;    @OneToOne(mappedBy = "job", cascade = CascadeType.ALL)    private ContactPersonEntity contactPerson;    @OneToMany(mappedBy = "job", cascade = CascadeType.ALL, orphanRemoval = true)    @OrderBy("orderIndex ASC")    private List<JobPhaseEntity> phases = new ArrayList<>();    @ElementCollection(fetch = FetchType.EAGER)    @CollectionTable(name = "available_phases", joinColumns = @JoinColumn(name = "job_id"))    @Column(name = "phase_name")    private List<String> availablePhases = new ArrayList<>();    @JoinColumn(name = "description")    private String description;    @JoinColumn(name = "salary")    private String salary;    @ManyToOne    @JoinColumn(name = "user_id")    private UserEntity user;    @Column(name = "created_at", nullable = false, updatable = false)    @CreatedDate    private Instant createdAt;    @Column(name = "updated_at")    @LastModifiedDate    private Instant updatedAt;    public JobEntity() {        initializeAvailablePhases();    }    private void initializeAvailablePhases() {        this.availablePhases = Arrays.stream(JobPhase.values())            .filter(e -> !e.getLabel().equals("Saved"))            .filter(e -> !e.getLabel().equals("Applied"))            .map(JobPhase::getLabel)            .toList();    }    public JobPhaseEntity currentPhase() {        return phases.stream()            .filter(e -> e.getStatus() == JobPhaseStatus.IN_PROGRESS)            .findAny()            .orElseThrow(() -> new IllegalStateException("incorrect state phases entity"));    }    public void removeAvailablePhase(String phaseName) {        availablePhases.remove(phaseName);    }    public void addPhase(JobPhaseEntity phase) {        this.phases.add(phase);        removeAvailablePhase(phase.getPhaseName());    }    public JobPhaseEntity nextPhase() {        int orderIndex = currentPhase().getOrderIndex();        return phases.stream()            .filter(e -> e.getOrderIndex() == orderIndex + 1)            .findFirst()            .orElseThrow(() -> new IllegalStateException("No next phase found"));    }}