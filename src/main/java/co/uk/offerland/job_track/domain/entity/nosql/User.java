package co.uk.offerland.job_track.domain.entity.nosql;import co.uk.offerland.job_track.application.dto.user.JobPhasesStatusEntity;import co.uk.offerland.job_track.domain.entity.PhaseStatus;import lombok.Data;import org.springframework.data.annotation.Id;import org.springframework.data.mongodb.core.index.Indexed;import org.springframework.data.mongodb.core.mapping.Document;import org.springframework.data.mongodb.core.mapping.Field;import java.util.*;import java.time.Instant;import java.util.stream.Collectors;import static co.uk.offerland.job_track.domain.entity.JobPhase.*;import static co.uk.offerland.job_track.domain.entity.PhaseStatus.*;import static co.uk.offerland.job_track.domain.entity.PhaseSubStatus.DONE;import static co.uk.offerland.job_track.domain.entity.PhaseSubStatus.WAIT_RESPONSE;import static java.util.Optional.ofNullable;@Data@Document(collection = "users")public class User {    @Id    private String id;    @Field("userId")    @Indexed(unique = true)    private UUID userId = UUID.randomUUID();    private String source;    private Instant createdAt;    private Instant updatedAt;    @Field("jobs")    private List<Job> jobs = new ArrayList<>();    private InterviewStat interviewStat;    public User(String source) {        this.source = source;        this.createdAt = Instant.now();        this.updatedAt = Instant.now();        interviewStat = new InterviewStat();    }    public JobPhasesStatusEntity getJobPhasesStatus() {        Map<PhaseStatus, Long> phaseStatusCounts = jobs.stream()                .flatMap(job -> job.getPhases().stream())                .map(Phase::getStatusInfoEntity)                .collect(Collectors.groupingBy(PhaseStatusInfoEntity::getStatus, Collectors.counting()));        Map<String, Long> phaseNameCounts = jobs.stream()                .flatMap(job -> job.getPhases().stream())                .filter(phase -> phase.getStatusInfoEntity().getStatus() == IN_PROGRESS)                .collect(Collectors.groupingBy(Phase::getPhaseName, Collectors.counting()));        long interviewCount = jobs.stream()                .flatMap(job -> job.getPhases().stream())                .filter(phase -> phase.getStatusInfoEntity().getStatus() == IN_PROGRESS)                .filter(phase -> {                    String phaseName = phase.getPhaseName();                    var subStatus = phase.getStatusInfoEntity().getSubStatus();                    return !phaseName.equals(SAVED.getLabel()) &&                            !phaseName.equals(APPLIED.getLabel()) &&                            !(phaseName.equals(OFFER_STATUS.getLabel()) && WAIT_RESPONSE == subStatus);                })                .count();        return JobPhasesStatusEntity.builder()                .savedCount(ofNullable(phaseNameCounts.get(SAVED.getLabel())).orElse(0L).intValue())                .appliedCount(ofNullable(phaseNameCounts.get(APPLIED.getLabel())).orElse(0L).intValue())                .interviewCount((int) interviewCount)                .rejectedCount(ofNullable(phaseStatusCounts.get(REJECTED)).orElse(0L).intValue())                .declinedCount(ofNullable(phaseStatusCounts.get(DECLINED)).orElse(0L).intValue())                .acceptedCount(ofNullable(phaseStatusCounts.get(ACCEPTED)).orElse(0L).intValue())                .build();    }}