package co.uk.offerland.job_track.domain.entity.nosql;import co.uk.offerland.job_track.application.dto.job.JobPhasesStatusEntity;import co.uk.offerland.job_track.domain.entity.PhaseStatus;import co.uk.offerland.job_track.domain.entity.PhaseSubStatus;import lombok.Data;import org.springframework.data.annotation.Id;import org.springframework.data.mongodb.core.index.Indexed;import org.springframework.data.mongodb.core.mapping.Document;import org.springframework.data.mongodb.core.mapping.Field;import java.time.Duration;import java.util.*;import java.time.Instant;import java.util.stream.Collectors;import static co.uk.offerland.job_track.domain.entity.PhaseName.*;import static co.uk.offerland.job_track.domain.entity.PhaseStatus.*;import static co.uk.offerland.job_track.domain.entity.PhaseSubStatus.PENDING_HR_REPLY;import static java.util.Optional.ofNullable;@Data@Document(collection = "users")public class User {    @Id    private String id;    @Field("userId")    @Indexed(unique = true)    private UUID userId;    private String email;    private String fullName;    private String source;    private Instant createdAt;    private Instant updatedAt;    @Field("jobs")    private List<Job> jobs = new ArrayList<>();    private InterviewStat interviewStat;    private String telegramRegisterId;    private String telegramUserId;    private Instant trialPeriodDate;    public User(UUID userId, String email, String fullName) {        this.userId = userId;        this.email = email;        this.fullName = fullName;        this.source = "chrome-extension";        this.createdAt = Instant.now();        this.updatedAt = Instant.now();        this.interviewStat = new InterviewStat();        this.telegramRegisterId = UUID.randomUUID().toString();        this.trialPeriodDate = Instant.now().plus(Duration.ofDays(30));    }    public JobPhasesStatusEntity getJobPhasesStatus() {        Map<PhaseStatus, Long> phaseStatusCounts = jobs.stream()                .flatMap(job -> job.getPhases().stream())                .map(Phase::getStatusInfoEntity)                .collect(Collectors.groupingBy(PhaseStatusInfoEntity::getStatus, Collectors.counting()));        Map<Boolean, Integer> savedPhases = jobs.stream()                .flatMap(job -> job.getPhases().stream())                .filter(phase -> phase.getStatusInfoEntity().getStatus() == IN_PROGRESS)                .filter(phase -> phase.getName().equals(APPLIED.getLabel()))                .collect(Collectors.partitioningBy(phase -> phase.getStatusInfoEntity().getSubStatus() == PhaseSubStatus.ACTION_REQUIRED, Collectors.summingInt(e -> 1)));        long interviewCount = jobs.stream()                .flatMap(job -> job.getPhases().stream())                .filter(phase -> phase.getStatusInfoEntity().getStatus() == IN_PROGRESS)                .filter(phase -> {                    String phaseName = phase.getName();                    var subStatus = phase.getStatusInfoEntity().getSubStatus();                    return !phaseName.equals(SAVED.getLabel()) &&                            !phaseName.equals(APPLIED.getLabel()) &&                            !(phaseName.equals(OFFER_STATUS.getLabel()) && PENDING_HR_REPLY == subStatus);                })                .count();        return JobPhasesStatusEntity.builder()                .savedCount(ofNullable(savedPhases.get(true)).orElse(0))                .appliedCount(ofNullable(savedPhases.get(false)).orElse(0))                .interviewCount((int) interviewCount)                .rejectedCount(ofNullable(phaseStatusCounts.get(REJECTED)).orElse(0L).intValue())                .declinedCount(ofNullable(phaseStatusCounts.get(DECLINED)).orElse(0L).intValue())                .acceptedCount(ofNullable(phaseStatusCounts.get(ACCEPTED)).orElse(0L).intValue())                .build();    }}