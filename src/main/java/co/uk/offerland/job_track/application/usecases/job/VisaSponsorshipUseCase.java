package co.uk.offerland.job_track.application.usecases.job;import co.uk.offerland.job_track.application.dto.*;import co.uk.offerland.job_track.infrastructure.ai.AIAssistant;import co.uk.offerland.job_track.infrastructure.converter.SearchVisaResponseConverter;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.ObjectMapper;import com.github.benmanes.caffeine.cache.Cache;import lombok.AllArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Service;import reactor.core.publisher.Mono;@Slf4j@Service@AllArgsConstructorpublic class VisaSponsorshipUseCase {    private static final double TOLERANCE = 0.000001;    private final Cache<String, CompanyVisaSponsorshipDto> visaSponsorshipCache;    private final Cache<String, RecognizeJobUrlResponse> jobUrlcache;    private final SearchVisaService searchVisaService;    private final SearchJobService searchJobService;    private final SearchVisaResponseConverter searchVisaResponseConverter;    private AIAssistant ragAssistant;    public Mono<CompanyVisaSponsorshipDto> searchVisa(CompanyJobTitleDetailsRequest request) {        String company = request.company().replaceAll("\\(remote\\)", "").trim();        String location = request.location();        String cacheKey = company + "_" + location;        var cachedValue = visaSponsorshipCache.getIfPresent(cacheKey);        if (cachedValue != null) {            return Mono.just(cachedValue);        }        return searchVisaService.search(String.format("%s %s", company, location))                .map(this::handleVisaResponse)                .map(result -> searchVisaResponseConverter.toDto(company, location, result))                .doOnNext(dto -> visaSponsorshipCache.put(cacheKey, dto))                .defaultIfEmpty(CompanyVisaSponsorshipDto.DEFAULT_VALUE);    }    private String handleVisaResponse(SearchVisaResponse result) {        log.info("handleVisaResponse: {}", result);        return result.distance() < 0.71d ? "Licensed Sponsor" : "";    }    public Mono<RecognizeJobUrlResponse> recognizeJob(RecognizeJobUrl request) {        String cacheKey = request.jobUrl();        var cachedValue = jobUrlcache.getIfPresent(cacheKey);        if (cachedValue != null) {            return Mono.just(cachedValue);        }        return searchJobService.search(request.jobUrl())                .flatMap(elem -> Mono.fromCallable(() -> ragAssistant.findJobDetails(elem))                        .flatMap(jobDetails -> {                            return Mono.just( parseJobDetails(jobDetails));                        }))                .doOnNext(dto -> jobUrlcache.put(cacheKey, dto))                .onErrorResume(error -> {                    log.error("Error during job recognition: {}", error);                    return Mono.just(new RecognizeJobUrlResponse("unknown", "unknown", "unknown", "unknown"));                });    }    private RecognizeJobUrlResponse parseJobDetails(String json) {        log.info("parseJobDetails: {}", json);        return toJobDetails(json);    }    private RecognizeJobUrlResponse toJobDetails(String json) {        try {            ObjectMapper mapper = new ObjectMapper();            JsonNode node = mapper.readTree(json);            return new RecognizeJobUrlResponse(                    node.path("company").asText("unknown"),                    node.path("jobTitle").asText("unknown"),                    node.path("location").asText("unknown"),                    node.path("salary").asText("unknown")            );        } catch (Exception e) {            return null;        }    }//    public Mono<RecognizeJobUrlResponse> recognizeJob(RecognizeJobUrl request) {//        Sinks.Many<String> sink = Sinks.many().unicast().onBackpressureBuffer();////        searchJobService.search(request.jobUrl())//                .flatMap(elem -> Mono.fromRunnable(() ->//                        ragAssistant.findJobDetails(elem)//                                .onPartialResponse(sink::tryEmitNext)//                                .onError(sink::tryEmitError)//                                .onCompleteResponse(response -> sink.emitComplete(Sinks.EmitFailureHandler.FAIL_FAST))//                                .start()//                ))//                .subscribe();////        return sink.asFlux()//                .collectList()//                .map(results -> new RecognizeJobUrlResponse(results));//    }}