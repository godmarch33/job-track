package co.uk.offerland.job_track.application.usecases.phase;import co.uk.offerland.job_track.application.dto.phase.AddPhaseRequest;import co.uk.offerland.job_track.application.dto.phase.PhaseResponse;import co.uk.offerland.job_track.application.dto.phase.PhasesResponse;import co.uk.offerland.job_track.application.usecases.phase.handlers.PhaseHandler;import co.uk.offerland.job_track.domain.entity.PhaseStatus;import co.uk.offerland.job_track.domain.entity.PhaseSubStatus;import co.uk.offerland.job_track.domain.entity.nosql.Job;import co.uk.offerland.job_track.domain.entity.nosql.Phase;import co.uk.offerland.job_track.domain.entity.nosql.User;import co.uk.offerland.job_track.infrastructure.converter.JobConverter;import co.uk.offerland.job_track.infrastructure.exception.InvalidPhaseException;import co.uk.offerland.job_track.infrastructure.exception.JobNotFoundException;import co.uk.offerland.job_track.infrastructure.exception.UserNotFoundException;import co.uk.offerland.job_track.infrastructure.persistence.UserRepository;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Service;import reactor.core.publisher.Mono;import reactor.util.function.Tuple2;import reactor.util.function.Tuples;import java.util.List;import java.util.UUID;@Slf4j@Service@RequiredArgsConstructorpublic class AddPhaseToJobUseCase {    private final UserRepository userRepository;    private final JobConverter jobConverter;    private final List<PhaseHandler> phaseHandlers;    public Mono<PhaseResponse> addPhase(UUID userId, UUID jobId, AddPhaseRequest request) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(                        new UserNotFoundException(String.format("User not found with userId:[%s]", userId))))                .flatMap(user -> user.getJobs().stream()                        .filter(job -> job.getJobId().equals(jobId))                        .findFirst()                        .map(job -> handleAddPhase(user, job, request))                        .orElseGet(() -> Mono.error(                                new JobNotFoundException(jobId.toString(), userId.toString())))                );    }    private Mono<PhaseResponse> handleAddPhase(User user, Job job, AddPhaseRequest request) {        log.info("Job found with jobId: [{}] for userId: [{}]", job.getJobId(), user.getUserId());        if (!job.getAvailablePhases().contains(request.getPhaseName())) {            throw new InvalidPhaseException(                    String.format("Phase [%s] not available for jobId [%s]",                            request.getPhaseName(), job.getJobId()));        }        var status = PhaseStatus.fromString(request.getStatus())                .orElseThrow(() -> new InvalidPhaseException(                        String.format("Invalid phase status: [%s]", request.getStatus())));        var newPhase = createJobPhaseEntity(request, status, job.getPhases().size());        job.addPhase(newPhase);        log.info("Added new phase [{}] to jobId [{}]", newPhase.getPhaseName(), job.getJobId());        return userRepository.save(user)                .map(updatedUser -> jobConverter.toPhaseResponse(newPhase));    }    public Mono<PhasesResponse> nextPhase(UUID userId, UUID jobId) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException(userId.toString())))                .flatMap(user -> findJob(user, jobId))                .flatMap(userJobTuple -> processJobPhases(userJobTuple))                .flatMap(this::saveUser)                .flatMap(this::phases);    }    private Phase createJobPhaseEntity(AddPhaseRequest request,                                       PhaseStatus status,                                       int currenPhaseSize) {        var newPhase = new Phase();        newPhase.setPhaseName(request.getPhaseName());        newPhase.setLastUpdatedDate(request.getDate());        newPhase.setStatus(status);        newPhase.setOrderIndex(++currenPhaseSize);        newPhase.setSubStatus(PhaseSubStatus.ACTION_REQUIRED);        return newPhase;    }    private Mono<Tuple2<User, Job>> findJob(User user, UUID jobId) {        return Mono.justOrEmpty(user.getJobs().stream()                        .filter(job -> job.getJobId().equals(jobId))                        .findFirst())                .map(job -> Tuples.of(user, job)) // Create a Tuple of UserEntity and JobEntity                .switchIfEmpty(Mono.error(new JobNotFoundException(jobId.toString(), user.getUserId().toString())));    }    private Mono<Job> saveUser(Tuple2<User, Job> userTuple) {        return userRepository.save(userTuple.getT1()) // Assuming JobEntity has a getUser() method                .thenReturn(userTuple.getT2());    }    private Mono<PhasesResponse> phases(Job jobEntity) {        return Mono.just(new PhasesResponse(jobEntity.getPhases().stream()                .map(jobConverter::toPhaseResponse)                .toList()));    }    private Mono<Tuple2<User, Job>> processJobPhases(Tuple2<User, Job> userTuple) {        Phase currentPhase = userTuple.getT2().currentPhase();        Phase nextPhase = userTuple.getT2().nextPhase();        phaseHandlers.stream()                .filter(handler -> handler.isApplicable(currentPhase))                .findAny()                .ifPresent(phaseHandler -> phaseHandler.handle(userTuple.getT1(), currentPhase, nextPhase));        return Mono.just(userTuple);    }}////         if (isScreenCallAndTimeForPrepare(currentPhase)) {//            updateScreenStatusTimeForPrepare(currentPhase, userId);//        } else if (isScreenCall(currentPhase)) {//            if (nextPhase.getInterviewScheduleTime() != null &&//                    nextPhase.getInterviewScheduleTime().isBefore(Instant.now())) {//                nextPhase.setStatusLabel(TIME_FOR_PREPARE_MSG);//            } else {//                nextPhase.setStatusLabel(WAIT_RESPONSE_MSG);//            }//            nextPhase.setStatus(PhaseStatus.IN_PROGRESS);//            nextPhase.setLastUpdatedDate(Instant.now());//            currentPhase.setStatus(PhaseStatus.COMPLETED);//        }//        return Mono.just(userTuple);//    }//    @Transactional//    public NextPhaseResponse addScheduleInterviewTimeJobPhase(UUID userId, UUID jobId, UUID phaseId,//                                                              SchedulePhaseRequest request) {//        String scheduleTimeString = request.getScheduleTime();//        if (scheduleTimeString == null || scheduleTimeString.isEmpty()) {//            log.error("Schedule time is missing for jobId: {}, phaseId: {}", jobId, phaseId);//            throw new IllegalArgumentException("Schedule time is required.");//        }//        var jobEntity = jobQueryService.getJobByUserIdAndJobId(userId, jobId);//        var currentPhase = jobEntity.currentPhase();//        Instant interviewScheduleTime = DateTimeUtil.convertStringToInstant(scheduleTimeString);//        JobPhaseEntity nextPhase = null;//        if (JobPhase.APPLIED.getLabel().equals(currentPhase.getPhaseName())) {//            nextPhase = jobEntity.nextPhase();//            nextPhase.setInterviewScheduleTime(interviewScheduleTime);//            log.info("Successfully scheduled job phase: jobId={}, phaseId={}, interviewScheduleTime={}",//                     jobId, nextPhase.getId(), interviewScheduleTime);//        }//        return new NextPhaseResponse(nextPhase.getPhaseName(), nextPhase.getInterviewScheduleTime());//        return null;//    }//        } else if (JobPhase.SCREENING_CALL.getLabel().equals(currentPhase.getPhaseName())) {//        } else if (JobPhase.ASSESSMENT_TEST.getLabel().equals(currentPhase.getPhaseName())) {//            if (TIME_FOR_PREPARE_MSG.equals(currentPhase.getActiveStatus())) {//                currentPhase.setActiveStatus(WAIT_RESPONSE_MSG);//                currentPhase.setLastUpdatedDate(Instant.now());//                log.info(//                    "Moved from status SCREENING_CALL to SCREENING_CALL with active status wait response for userId: [{}] ,phaseId: [{}]",//                    userId, currentPhase.getId());//            } else {//                JobPhaseEntity nextPhase = jobEntity.nextPhase();//                nextPhase.setStatus(JobPhaseStatus.IN_PROGRESS);//                if (nextPhase.getInterviewScheduleTime() != null && nextPhase.getInterviewScheduleTime()//                    .isBefore(Instant.now())) {//                    nextPhase.setActiveStatus(TIME_FOR_PREPARE_MSG);//                } else {//                    nextPhase.setActiveStatus(WAIT_RESPONSE_MSG);//                }//                nextPhase.setLastUpdatedDate(Instant.now());//                currentPhase.setActiveStatus("Done");//                currentPhase.setStatus(JobPhaseStatus.COMPLETED);//            }//        } else if (JobPhase.FIRST_ROUND.getLabel().equals(currentPhase.getPhaseName())) {//            if (TIME_FOR_PREPARE_MSG.equals(currentPhase.getActiveStatus())) {//                currentPhase.setActiveStatus(WAIT_RESPONSE_MSG);//                currentPhase.setLastUpdatedDate(Instant.now());//                log.info(//                    "Moved from status SCREENING_CALL to SCREENING_CALL with active status wait response for userId: [{}] ,phaseId: [{}]",//                    userId, currentPhase.getId());//            } else {//                JobPhaseEntity nextPhase = jobEntity.nextPhase();//                nextPhase.setStatus(JobPhaseStatus.IN_PROGRESS);//                if (nextPhase.getInterviewScheduleTime() != null && nextPhase.getInterviewScheduleTime()//                    .isBefore(Instant.now())) {//                    nextPhase.setActiveStatus(TIME_FOR_PREPARE_MSG);//                } else {//                    nextPhase.setActiveStatus(WAIT_RESPONSE_MSG);//                }//                nextPhase.setLastUpdatedDate(Instant.now());//                currentPhase.setActiveStatus("Done");//                currentPhase.setStatus(JobPhaseStatus.COMPLETED);//            }//        } else if (JobPhase.SECOND_ROUND.getLabel().equals(currentPhase.getPhaseName())) {//            if (TIME_FOR_PREPARE_MSG.equals(currentPhase.getActiveStatus())) {//                currentPhase.setActiveStatus(WAIT_RESPONSE_MSG);//                currentPhase.setLastUpdatedDate(Instant.now());//                log.info(//                    "Moved from status SCREENING_CALL to SCREENING_CALL with active status wait response for userId: [{}] ,phaseId: [{}]",//                    userId, currentPhase.getId());//            } else {//                JobPhaseEntity nextPhase = jobEntity.nextPhase();//                nextPhase.setStatus(JobPhaseStatus.IN_PROGRESS);//                if (nextPhase.getInterviewScheduleTime() != null && nextPhase.getInterviewScheduleTime()//                    .isBefore(Instant.now())) {//                    nextPhase.setActiveStatus(TIME_FOR_PREPARE_MSG);//                } else {//                    nextPhase.setActiveStatus(WAIT_RESPONSE_MSG);//                }//                nextPhase.setLastUpdatedDate(Instant.now());//                currentPhase.setActiveStatus("Done");//                currentPhase.setStatus(JobPhaseStatus.COMPLETED);//            }//        } else if (JobPhase.THIRD_ROUND.getLabel().equals(currentPhase.getPhaseName())) {//            if (TIME_FOR_PREPARE_MSG.equals(currentPhase.getActiveStatus())) {//                currentPhase.setActiveStatus(WAIT_RESPONSE_MSG);//                currentPhase.setLastUpdatedDate(Instant.now());//                log.info(//                    "Moved from status SCREENING_CALL to SCREENING_CALL with active status wait response for userId: [{}] ,phaseId: [{}]",//                    userId, currentPhase.getId());//            } else {//                JobPhaseEntity nextPhase = jobEntity.nextPhase();//                nextPhase.setStatus(JobPhaseStatus.IN_PROGRESS);//                if (nextPhase.getInterviewScheduleTime() != null && nextPhase.getInterviewScheduleTime()//                    .isBefore(Instant.now())) {//                    nextPhase.setActiveStatus(TIME_FOR_PREPARE_MSG);//                } else {//                    nextPhase.setActiveStatus(WAIT_RESPONSE_MSG);//                }//                nextPhase.setLastUpdatedDate(Instant.now());//                currentPhase.setActiveStatus("Done");//                currentPhase.setStatus(JobPhaseStatus.COMPLETED);//            }//        } else if (JobPhase.FINAL_ROUND.getLabel().equals(currentPhase.getPhaseName())) {//            if (TIME_FOR_PREPARE_MSG.equals(currentPhase.getActiveStatus())) {//                currentPhase.setActiveStatus(WAIT_RESPONSE_MSG);//                currentPhase.setLastUpdatedDate(Instant.now());//                log.info(//                    "Moved from status SCREENING_CALL to SCREENING_CALL with active status wait response for userId: [{}] ,phaseId: [{}]",//                    userId, currentPhase.getId());//            } else {//                JobPhaseEntity nextPhase = jobEntity.nextPhase();//                nextPhase.setStatus(JobPhaseStatus.IN_PROGRESS);//                if (nextPhase.getInterviewScheduleTime() != null && nextPhase.getInterviewScheduleTime()//                    .isBefore(Instant.now())) {//                    nextPhase.setActiveStatus(TIME_FOR_PREPARE_MSG);//                } else {//                    nextPhase.setActiveStatus(WAIT_RESPONSE_MSG);//                }//                nextPhase.setLastUpdatedDate(Instant.now());//                currentPhase.setActiveStatus("Done");//                currentPhase.setStatus(JobPhaseStatus.COMPLETED);//            }//        } else if (JobPhase.OFFER_STATUS.getLabel().equals(currentPhase.getPhaseName())) {//            currentPhase.setActiveStatus("Offer Accepted");//            currentPhase.setLastUpdatedDate(Instant.now());//            currentPhase.setStatus(JobPhaseStatus.COMPLETED);//        }////        List<PhaseResponse> addPhaseResponses =//            jobEntity.getPhases().stream()//                .map(phase -> jobConverter.toResponse(phase))//                .toList();////        return new AddPhasesResponse(addPhaseResponses);//}//    public AddPhasesResponse offer(UUID userId, UUID jobId, OfferRequest request) {//        var jobEntity = jobQueryService.getJobByUserIdAndJobId(userId, jobId);//        var currentPhase = jobEntity.currentPhase();//        if (currentPhase.getPhaseName().equals(JobPhase.OFFER_STATUS.getLabel())) {//            currentPhase.setActiveStatus(request.getOfferAction());//            currentPhase.setLastUpdatedDate(Instant.now());//            if (request.getOfferAction().equals("Accept Offer")) {//                currentPhase.setStatus(JobPhaseStatus.COMPLETED);//            } else if (request.getOfferAction().equals("Decline Offer")) {//                currentPhase.setStatus(JobPhaseStatus.DECLINED);//            } else if (request.getOfferAction().equals("Reject Offer")) {//                currentPhase.setStatus(JobPhaseStatus.REJECTED);//            }//            jobRepository.save(jobEntity);//        }//        List<PhaseResponse> addPhaseResponses =//            jobEntity.getPhases().stream()//                .map(phase -> jobConverter.toResponse(phase))//                .toList();////        return new AddPhasesResponse(addPhaseResponses);//        return null;//    }//}