package co.uk.offerland.job_track.application.usecases.phase;import static co.uk.offerland.job_track.application.usecases.user.AssignJobToUserUseCase.ACTION_REQUIRED_MSG;import static co.uk.offerland.job_track.application.usecases.user.AssignJobToUserUseCase.TIME_FOR_PREPARE_MSG;import static co.uk.offerland.job_track.application.usecases.user.AssignJobToUserUseCase.WAIT_RESPONSE_MSG;import java.time.Instant;import java.util.List;import java.util.UUID;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import co.uk.offerland.job_track.application.dto.NextPhaseResponse;import co.uk.offerland.job_track.application.dto.phase.AddPhaseRequest;import co.uk.offerland.job_track.application.dto.phase.AddPhasesResponse;import co.uk.offerland.job_track.application.dto.phase.OfferRequest;import co.uk.offerland.job_track.application.dto.phase.PhaseResponse;import co.uk.offerland.job_track.application.dto.phase.SchedulePhaseRequest;import co.uk.offerland.job_track.application.query.JobQueryService;import co.uk.offerland.job_track.domain.entity.JobEntity;import co.uk.offerland.job_track.domain.entity.JobPhase;import co.uk.offerland.job_track.domain.entity.JobPhaseEntity;import co.uk.offerland.job_track.domain.entity.JobPhaseStatus;import co.uk.offerland.job_track.infrastructure.converter.JobConverter;import co.uk.offerland.job_track.infrastructure.exception.InvalidPhaseException;import co.uk.offerland.job_track.infrastructure.persistence.jdbc.JobJdbcRepository;import co.uk.offerland.job_track.infrastructure.util.DateTimeUtil;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;@Service@Slf4j@RequiredArgsConstructorpublic class AddPhaseToJobUseCase {    private final JobQueryService jobQueryService;    private final JobJdbcRepository jobRepository;    private final JobConverter jobConverter;    @Transactional    public PhaseResponse add(UUID userId, UUID jobId, AddPhaseRequest request) {        var job = jobQueryService.getJobByUserIdAndJobId(userId, jobId);        log.info("Retrieved job {} for user {}", jobId, userId);        if (!job.getAvailablePhases().contains(request.getPhaseName())) {            throw new InvalidPhaseException(                String.format("Phase:%s not available for this jobId:%s", request.getPhaseName(), jobId));        }        var status = JobPhaseStatus.fromString(request.getStatus())            .orElseThrow(() -> new InvalidPhaseException("Invalid phase status: " + request.getStatus()));        var newPhase = createJobPhaseEntity(request, job, status, job.getPhases().size());        job.addPhase(newPhase);        log.info("Added new phase {} to job {}", request.getPhaseName(), jobId);        JobEntity savedJob = jobRepository.save(job);        log.info("Job {} updated successfully", jobId);        JobPhaseEntity savedPhase = savedJob.getPhases().stream()            .filter(e -> e.getPhaseName().equals(newPhase.getPhaseName()))            .findFirst()            .orElseThrow(() -> new IllegalStateException("Phase was not saved properly"));        log.info("Returning response for phase {}", savedPhase.getPhaseName());        return jobConverter.toResponse(savedPhase);    }    private JobPhaseEntity createJobPhaseEntity(AddPhaseRequest request, JobEntity job, JobPhaseStatus status,                                                int currenPhaseSize) {        JobPhaseEntity newPhase = new JobPhaseEntity();        newPhase.setJob(job);        newPhase.setPhaseName(request.getPhaseName());        newPhase.setLastUpdatedDate(request.getDate());        newPhase.setStatus(status);        newPhase.setOrderIndex(++currenPhaseSize);        return newPhase;    }    @Transactional    public NextPhaseResponse addScheduleInterviewTimeJobPhase(UUID userId, UUID jobId, UUID phaseId,                                                              SchedulePhaseRequest request) {        String scheduleTimeString = request.getScheduleTime();        if (scheduleTimeString == null || scheduleTimeString.isEmpty()) {            log.error("Schedule time is missing for jobId: {}, phaseId: {}", jobId, phaseId);            throw new IllegalArgumentException("Schedule time is required.");        }        var jobEntity = jobQueryService.getJobByUserIdAndJobId(userId, jobId);        var currentPhase = jobEntity.currentPhase();        Instant interviewScheduleTime = DateTimeUtil.convertStringToInstant(scheduleTimeString);        JobPhaseEntity nextPhase = null;        if (JobPhase.APPLIED.getLabel().equals(currentPhase.getPhaseName())) {            nextPhase = jobEntity.nextPhase();            nextPhase.setInterviewScheduleTime(interviewScheduleTime);            log.info("Successfully scheduled job phase: jobId={}, phaseId={}, interviewScheduleTime={}",                     jobId, nextPhase.getId(), interviewScheduleTime);        }        return new NextPhaseResponse(nextPhase.getPhaseName(), nextPhase.getInterviewScheduleTime());    }    @Transactional    public AddPhasesResponse nextPhase(UUID userId, UUID jobId) {        var jobEntity = jobQueryService.getJobByUserIdAndJobId(userId, jobId);        var currentPhase = jobEntity.currentPhase();        if (JobPhase.APPLIED.getLabel().equals(currentPhase.getPhaseName())) {            if (ACTION_REQUIRED_MSG.equals(currentPhase.getActiveStatus())) {                currentPhase.setActiveStatus(WAIT_RESPONSE_MSG);                currentPhase.setLastUpdatedDate(Instant.now());                log.info(                    "Moved from status APPLIED to APPLIED with active status wait response for userId: [{}] ,phaseId: [{}]",                    userId, currentPhase.getId());            } else {                JobPhaseEntity nextPhase = jobEntity.nextPhase();                nextPhase.setStatus(JobPhaseStatus.IN_PROGRESS);                if (nextPhase.getInterviewScheduleTime() != null && nextPhase.getInterviewScheduleTime()                    .isBefore(Instant.now())) {                    nextPhase.setActiveStatus(TIME_FOR_PREPARE_MSG);                } else {                    nextPhase.setActiveStatus(WAIT_RESPONSE_MSG);                }                nextPhase.setLastUpdatedDate(Instant.now());                currentPhase.setActiveStatus("Done");                currentPhase.setStatus(JobPhaseStatus.COMPLETED);            }        } else if (JobPhase.SCREENING_CALL.getLabel().equals(currentPhase.getPhaseName())) {            if (TIME_FOR_PREPARE_MSG.equals(currentPhase.getActiveStatus())) {                currentPhase.setActiveStatus(WAIT_RESPONSE_MSG);                currentPhase.setLastUpdatedDate(Instant.now());                log.info(                    "Moved from status SCREENING_CALL to SCREENING_CALL with active status wait response for userId: [{}] ,phaseId: [{}]",                    userId, currentPhase.getId());            } else {                JobPhaseEntity nextPhase = jobEntity.nextPhase();                nextPhase.setStatus(JobPhaseStatus.IN_PROGRESS);                if (nextPhase.getInterviewScheduleTime() != null && nextPhase.getInterviewScheduleTime()                    .isBefore(Instant.now())) {                    nextPhase.setActiveStatus(TIME_FOR_PREPARE_MSG);                } else {                    nextPhase.setActiveStatus(WAIT_RESPONSE_MSG);                }                nextPhase.setLastUpdatedDate(Instant.now());                currentPhase.setActiveStatus("Done");                currentPhase.setStatus(JobPhaseStatus.COMPLETED);            }        } else if (JobPhase.ASSESSMENT_TEST.getLabel().equals(currentPhase.getPhaseName())) {            if (TIME_FOR_PREPARE_MSG.equals(currentPhase.getActiveStatus())) {                currentPhase.setActiveStatus(WAIT_RESPONSE_MSG);                currentPhase.setLastUpdatedDate(Instant.now());                log.info(                    "Moved from status SCREENING_CALL to SCREENING_CALL with active status wait response for userId: [{}] ,phaseId: [{}]",                    userId, currentPhase.getId());            } else {                JobPhaseEntity nextPhase = jobEntity.nextPhase();                nextPhase.setStatus(JobPhaseStatus.IN_PROGRESS);                if (nextPhase.getInterviewScheduleTime() != null && nextPhase.getInterviewScheduleTime()                    .isBefore(Instant.now())) {                    nextPhase.setActiveStatus(TIME_FOR_PREPARE_MSG);                } else {                    nextPhase.setActiveStatus(WAIT_RESPONSE_MSG);                }                nextPhase.setLastUpdatedDate(Instant.now());                currentPhase.setActiveStatus("Done");                currentPhase.setStatus(JobPhaseStatus.COMPLETED);            }        } else if (JobPhase.FIRST_ROUND.getLabel().equals(currentPhase.getPhaseName())) {            if (TIME_FOR_PREPARE_MSG.equals(currentPhase.getActiveStatus())) {                currentPhase.setActiveStatus(WAIT_RESPONSE_MSG);                currentPhase.setLastUpdatedDate(Instant.now());                log.info(                    "Moved from status SCREENING_CALL to SCREENING_CALL with active status wait response for userId: [{}] ,phaseId: [{}]",                    userId, currentPhase.getId());            } else {                JobPhaseEntity nextPhase = jobEntity.nextPhase();                nextPhase.setStatus(JobPhaseStatus.IN_PROGRESS);                if (nextPhase.getInterviewScheduleTime() != null && nextPhase.getInterviewScheduleTime()                    .isBefore(Instant.now())) {                    nextPhase.setActiveStatus(TIME_FOR_PREPARE_MSG);                } else {                    nextPhase.setActiveStatus(WAIT_RESPONSE_MSG);                }                nextPhase.setLastUpdatedDate(Instant.now());                currentPhase.setActiveStatus("Done");                currentPhase.setStatus(JobPhaseStatus.COMPLETED);            }        } else if (JobPhase.SECOND_ROUND.getLabel().equals(currentPhase.getPhaseName())) {            if (TIME_FOR_PREPARE_MSG.equals(currentPhase.getActiveStatus())) {                currentPhase.setActiveStatus(WAIT_RESPONSE_MSG);                currentPhase.setLastUpdatedDate(Instant.now());                log.info(                    "Moved from status SCREENING_CALL to SCREENING_CALL with active status wait response for userId: [{}] ,phaseId: [{}]",                    userId, currentPhase.getId());            } else {                JobPhaseEntity nextPhase = jobEntity.nextPhase();                nextPhase.setStatus(JobPhaseStatus.IN_PROGRESS);                if (nextPhase.getInterviewScheduleTime() != null && nextPhase.getInterviewScheduleTime()                    .isBefore(Instant.now())) {                    nextPhase.setActiveStatus(TIME_FOR_PREPARE_MSG);                } else {                    nextPhase.setActiveStatus(WAIT_RESPONSE_MSG);                }                nextPhase.setLastUpdatedDate(Instant.now());                currentPhase.setActiveStatus("Done");                currentPhase.setStatus(JobPhaseStatus.COMPLETED);            }        } else if (JobPhase.THIRD_ROUND.getLabel().equals(currentPhase.getPhaseName())) {            if (TIME_FOR_PREPARE_MSG.equals(currentPhase.getActiveStatus())) {                currentPhase.setActiveStatus(WAIT_RESPONSE_MSG);                currentPhase.setLastUpdatedDate(Instant.now());                log.info(                    "Moved from status SCREENING_CALL to SCREENING_CALL with active status wait response for userId: [{}] ,phaseId: [{}]",                    userId, currentPhase.getId());            } else {                JobPhaseEntity nextPhase = jobEntity.nextPhase();                nextPhase.setStatus(JobPhaseStatus.IN_PROGRESS);                if (nextPhase.getInterviewScheduleTime() != null && nextPhase.getInterviewScheduleTime()                    .isBefore(Instant.now())) {                    nextPhase.setActiveStatus(TIME_FOR_PREPARE_MSG);                } else {                    nextPhase.setActiveStatus(WAIT_RESPONSE_MSG);                }                nextPhase.setLastUpdatedDate(Instant.now());                currentPhase.setActiveStatus("Done");                currentPhase.setStatus(JobPhaseStatus.COMPLETED);            }        } else if (JobPhase.FINAL_ROUND.getLabel().equals(currentPhase.getPhaseName())) {            if (TIME_FOR_PREPARE_MSG.equals(currentPhase.getActiveStatus())) {                currentPhase.setActiveStatus(WAIT_RESPONSE_MSG);                currentPhase.setLastUpdatedDate(Instant.now());                log.info(                    "Moved from status SCREENING_CALL to SCREENING_CALL with active status wait response for userId: [{}] ,phaseId: [{}]",                    userId, currentPhase.getId());            } else {                JobPhaseEntity nextPhase = jobEntity.nextPhase();                nextPhase.setStatus(JobPhaseStatus.IN_PROGRESS);                if (nextPhase.getInterviewScheduleTime() != null && nextPhase.getInterviewScheduleTime()                    .isBefore(Instant.now())) {                    nextPhase.setActiveStatus(TIME_FOR_PREPARE_MSG);                } else {                    nextPhase.setActiveStatus(WAIT_RESPONSE_MSG);                }                nextPhase.setLastUpdatedDate(Instant.now());                currentPhase.setActiveStatus("Done");                currentPhase.setStatus(JobPhaseStatus.COMPLETED);            }        } else if (JobPhase.OFFER_STATUS.getLabel().equals(currentPhase.getPhaseName())) {            currentPhase.setActiveStatus("Offer Accepted");            currentPhase.setLastUpdatedDate(Instant.now());            currentPhase.setStatus(JobPhaseStatus.COMPLETED);        }        List<PhaseResponse> addPhaseResponses =            jobEntity.getPhases().stream()                .map(phase -> jobConverter.toResponse(phase))                .toList();        return new AddPhasesResponse(addPhaseResponses);    }    @Transactional    public AddPhasesResponse offer(UUID userId, UUID jobId, OfferRequest request) {        var jobEntity = jobQueryService.getJobByUserIdAndJobId(userId, jobId);        var currentPhase = jobEntity.currentPhase();        if (currentPhase.getPhaseName().equals(JobPhase.OFFER_STATUS.getLabel())) {            currentPhase.setActiveStatus(request.getOfferAction());            currentPhase.setLastUpdatedDate(Instant.now());            if (request.getOfferAction().equals("Accept Offer")) {                currentPhase.setStatus(JobPhaseStatus.COMPLETED);            } else if (request.getOfferAction().equals("Decline Offer")) {                currentPhase.setStatus(JobPhaseStatus.DECLINED);            } else if (request.getOfferAction().equals("Reject Offer")) {                currentPhase.setStatus(JobPhaseStatus.REJECTED);            }            jobRepository.save(jobEntity);        }        List<PhaseResponse> addPhaseResponses =            jobEntity.getPhases().stream()                .map(phase -> jobConverter.toResponse(phase))                .toList();        return new AddPhasesResponse(addPhaseResponses);    }}