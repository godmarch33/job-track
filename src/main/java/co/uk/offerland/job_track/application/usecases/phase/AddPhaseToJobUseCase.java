package co.uk.offerland.job_track.application.usecases.phase;import co.uk.offerland.job_track.application.dto.NextPhaseResponse;import co.uk.offerland.job_track.application.dto.phase.AddPhaseRequest;import co.uk.offerland.job_track.application.dto.phase.PhaseResponse;import co.uk.offerland.job_track.application.dto.phase.PhasesResponse;import co.uk.offerland.job_track.application.dto.phase.ScheduleInterviewRequest;import co.uk.offerland.job_track.application.dto.user.ListJobs;import co.uk.offerland.job_track.application.usecases.phase.handlers.PhaseHandler;import co.uk.offerland.job_track.domain.entity.JobPhase;import co.uk.offerland.job_track.domain.entity.PhaseStatus;import co.uk.offerland.job_track.domain.entity.PhaseSubStatus;import co.uk.offerland.job_track.domain.entity.nosql.Job;import co.uk.offerland.job_track.domain.entity.nosql.Phase;import co.uk.offerland.job_track.domain.entity.nosql.PhaseStatusInfoEntity;import co.uk.offerland.job_track.domain.entity.nosql.User;import co.uk.offerland.job_track.infrastructure.converter.JobConverter;import co.uk.offerland.job_track.infrastructure.exception.InvalidPhaseException;import co.uk.offerland.job_track.infrastructure.exception.JobNotFoundException;import co.uk.offerland.job_track.infrastructure.exception.UserNotFoundException;import co.uk.offerland.job_track.infrastructure.persistence.UserRepository;import co.uk.offerland.job_track.infrastructure.util.DateTimeUtil;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.tuple.Pair;import org.springframework.stereotype.Service;import reactor.core.publisher.Flux;import reactor.core.publisher.Mono;import reactor.util.function.Tuple2;import reactor.util.function.Tuples;import java.time.Instant;import java.util.List;import java.util.Objects;import java.util.UUID;import static org.apache.commons.lang3.tuple.Pair.of;@Slf4j@Service@RequiredArgsConstructorpublic class AddPhaseToJobUseCase {    private final UserRepository userRepository;    private final JobConverter jobConverter;    private final List<PhaseHandler> phaseHandlers;    public Mono<PhaseResponse> addPhase(UUID userId, UUID jobId, AddPhaseRequest request) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(                        new UserNotFoundException(String.format("User not found with userId:[%s]", userId))))                .flatMap(user -> user.getJobs().stream()                        .filter(job -> job.getJobId().equals(jobId))                        .findFirst()                        .map(job -> handleAddPhase(user, job, request))                        .orElseGet(() -> Mono.error(                                new JobNotFoundException(jobId.toString(), userId.toString())))                );    }    private Mono<PhaseResponse> handleAddPhase(User user, Job job, AddPhaseRequest request) {        log.info("Job found with jobId: [{}] for userId: [{}]", job.getJobId(), user.getUserId());        if (!job.getAvailablePhases().contains(request.getPhaseName())) {            throw new InvalidPhaseException(                    String.format("Phase [%s] not available for jobId [%s]",                            request.getPhaseName(), job.getJobId()));        }        var newPhase = createJobPhaseEntity(request.getPhaseName(),                PhaseStatus.NOT_STARTED,                PhaseSubStatus.ACTION_REQUIRED,                "Next Stage",                "Proceed to next stage",                job.getPhases().size());        job.addPhase(newPhase);        log.info("Added new phase [{}] to jobId [{}]", newPhase.getPhaseName(), job.getJobId());        return userRepository.save(user)                .map(updatedUser -> jobConverter.toPhaseResponse(newPhase));    }    public Mono<PhasesResponse> nextPhase(UUID userId, UUID jobId) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException(userId.toString())))                .flatMap(user -> findJob(user, jobId))                .flatMap(userJobTuple -> processJobPhases(userJobTuple))                .flatMap(this::saveUser)                .flatMap(this::phases);    }    private Phase createJobPhaseEntity(String phaseName,                                       PhaseStatus status,                                       PhaseSubStatus subStatus,                                       String stageButtonName,                                       String msgTooltip,                                       int currenPhaseSize) {        var newPhase = new Phase();        newPhase.setPhaseName(phaseName);        newPhase.setLastUpdatedDate(Instant.now());        PhaseStatusInfoEntity statusInfoEntity = new PhaseStatusInfoEntity();        statusInfoEntity.setStatus(status);        statusInfoEntity.setSubStatus(subStatus);        statusInfoEntity.setNextStageButtonName(stageButtonName);        statusInfoEntity.setMsgTooltip(msgTooltip);        newPhase.setStatusInfoEntity(statusInfoEntity);        newPhase.setOrderIndex(++currenPhaseSize);        return newPhase;    }    private Mono<Tuple2<User, Job>> findJob(User user, UUID jobId) {        return Mono.justOrEmpty(user.getJobs().stream()                        .filter(job -> job.getJobId().equals(jobId))                        .findFirst())                .map(job -> Tuples.of(user, job))                .switchIfEmpty(Mono.error(new JobNotFoundException(jobId.toString(), user.getUserId().toString())));    }    private Mono<Tuple2<User, Job>> saveUser(Tuple2<User, Job> userTuple) {        return userRepository.save(userTuple.getT1()).map(e -> Tuples.of(e,userTuple.getT2()));    }    private Mono<PhasesResponse> phases(Tuple2<User, Job> userTuple) {        ListJobs jobsResponse = jobConverter.toJobsResponse(userTuple.getT1());        Flux<PhaseResponse> phaseResponses = Flux.fromIterable(userTuple.getT2().getPhases())                .map(jobConverter::toPhaseResponse);        return phaseResponses.collectList()                .map(phaseList -> new PhasesResponse(                        phaseList,                        jobsResponse.getInterviewStats(),                        jobsResponse.getJobPhasesStatus()                ));    }    private Mono<Tuple2<User, Job>> processJobPhases(Tuple2<User, Job> userTuple) {        Phase currentPhase = userTuple.getT2().currentPhase();        Phase nextPhase = userTuple.getT2().nextPhase();        log.info("nextPhase: [{}]", nextPhase);        if (Objects.isNull(nextPhase)) {           throw new InvalidPhaseException("No nextPhase found for jobId: " + userTuple.getT2().getJobId());        }        phaseHandlers.stream()                .filter(handler -> handler.isApplicable(currentPhase))                .findAny()                .orElseThrow(() -> new InvalidPhaseException("No handler found for phase: " + currentPhase))                .handle(userTuple.getT1(), currentPhase, nextPhase);        return Mono.just(userTuple);    }    public Mono<Pair<User, Job>> findUserByIdAndJobId(UUID userId, UUID jobId) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException(userId.toString())))                .flatMap(user -> Mono.justOrEmpty(user.getJobs().stream()                                .filter(job -> job.getJobId().equals(jobId))                                .findFirst())                        .switchIfEmpty(Mono.error(new JobNotFoundException(userId.toString(), jobId.toString())))                        .map(job -> of(user, job)));    }    public Mono<NextPhaseResponse> scheduleInterview(UUID userId,                                                     UUID jobId,                                                     UUID phaseId,                                                     ScheduleInterviewRequest request) {        return Mono.just(request)                .filter(req -> req.getScheduleTime() != null && !req.getScheduleTime().isEmpty())                .switchIfEmpty(Mono.error(new IllegalArgumentException("Schedule time is required.")))                .flatMap(req -> findUserByIdAndJobId(userId, jobId))                .flatMap(pair -> {                    Job job = pair.getValue();                    try {                        Instant interviewScheduleTime = DateTimeUtil.convertStringToInstant(request.getScheduleTime());                        Phase nextPhase = job.nextPhase();                        nextPhase.setInterviewScheduleTime(interviewScheduleTime);                        log.info("Successfully scheduled interview for job: {}, phase: {}, interviewScheduleTime: {}",                                jobId, nextPhase.getJobPhaseId(), interviewScheduleTime);                        return userRepository.save(pair.getKey())                                .thenReturn(new NextPhaseResponse(nextPhase.getPhaseName(), nextPhase.getInterviewScheduleTime()));                    } catch (IllegalArgumentException e) {                        log.error("Invalid schedule time format for job: {}, phase: {}", jobId, phaseId, e);                        return Mono.error(new IllegalArgumentException("Invalid schedule time format."));                    }                });    }}//    public AddPhasesResponse offer(UUID userId, UUID jobId, OfferRequest request) {//        var jobEntity = jobQueryService.getJobByUserIdAndJobId(userId, jobId);//        var currentPhase = jobEntity.currentPhase();//        if (currentPhase.getPhaseName().equals(JobPhase.OFFER_STATUS.getLabel())) {//            currentPhase.setActiveStatus(request.getOfferAction());//            currentPhase.setLastUpdatedDate(Instant.now());//            if (request.getOfferAction().equals("Accept Offer")) {//                currentPhase.setStatus(JobPhaseStatus.COMPLETED);//            } else if (request.getOfferAction().equals("Decline Offer")) {//                currentPhase.setStatus(JobPhaseStatus.DECLINED);//            } else if (request.getOfferAction().equals("Reject Offer")) {//                currentPhase.setStatus(JobPhaseStatus.REJECTED);//            }//            jobRepository.save(jobEntity);//        }//        List<PhaseResponse> addPhaseResponses =//            jobEntity.getPhases().stream()//                .map(phase -> jobConverter.toResponse(phase))//                .toList();////        return new AddPhasesResponse(addPhaseResponses);//        return null;//    }//}