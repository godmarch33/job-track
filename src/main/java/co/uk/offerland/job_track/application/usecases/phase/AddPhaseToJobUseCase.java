package co.uk.offerland.job_track.application.usecases.phase;import co.uk.offerland.job_track.application.dto.NextPhaseResponse;import co.uk.offerland.job_track.application.dto.phase.*;import co.uk.offerland.job_track.application.dto.job.JobPhasesStatusEntity;import co.uk.offerland.job_track.application.dto.job.ListJobs;import co.uk.offerland.job_track.application.usecases.phase.handlers.PhaseHandler;import co.uk.offerland.job_track.domain.entity.PhaseStatus;import co.uk.offerland.job_track.domain.entity.PhaseSubStatus;import co.uk.offerland.job_track.domain.entity.nosql.Job;import co.uk.offerland.job_track.domain.entity.nosql.Phase;import co.uk.offerland.job_track.domain.entity.nosql.PhaseStatusInfoEntity;import co.uk.offerland.job_track.domain.entity.nosql.User;import co.uk.offerland.job_track.infrastructure.converter.JobConverter;import co.uk.offerland.job_track.infrastructure.exception.InvalidPhaseException;import co.uk.offerland.job_track.infrastructure.exception.JobNotFoundException;import co.uk.offerland.job_track.infrastructure.exception.PhaseNotFoundException;import co.uk.offerland.job_track.infrastructure.exception.UserNotFoundException;import co.uk.offerland.job_track.infrastructure.persistence.UserRepository;import co.uk.offerland.job_track.infrastructure.util.DateTimeUtil;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.tuple.Pair;import org.springframework.stereotype.Service;import reactor.core.publisher.Flux;import reactor.core.publisher.Mono;import reactor.util.function.Tuple2;import reactor.util.function.Tuples;import java.time.Instant;import java.util.List;import java.util.Objects;import java.util.UUID;import static org.apache.commons.lang3.tuple.Pair.of;@Slf4j@Service@RequiredArgsConstructorpublic class AddPhaseToJobUseCase {    private final UserRepository userRepository;    private final JobConverter jobConverter;    private final List<PhaseHandler> phaseHandlers;    public Mono<PhaseResponse> addPhase(UUID userId, UUID jobId, AddPhaseRequest request) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(                        new UserNotFoundException(String.format("User not found with userId:[%s]", userId))))                .flatMap(user -> user.getJobs().stream()                        .filter(job -> job.getJobId().equals(jobId))                        .findFirst()                        .map(job -> handleAddPhase(user, job, request))                        .orElseGet(() -> Mono.error(                                new JobNotFoundException(jobId.toString(), userId.toString())))                );    }    public Mono<PhaseResponse> removePhase(UUID userId, UUID jobId, UUID phaseId) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(                        new UserNotFoundException(String.format("User not found with userId:[%s]", userId))))                .flatMap(user -> user.getJobs().stream()                        .filter(job -> job.getJobId().equals(jobId))                        .findFirst()                        .map(job -> removePhase(user, job, phaseId))                        .orElseGet(() -> Mono.error(                                new JobNotFoundException(jobId.toString(), userId.toString())))                );    }    public Mono<PhasesResponse> nextPhase(UUID userId, UUID jobId) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException(userId.toString())))                .flatMap(user -> findJob(user, jobId))                .flatMap(userJobTuple -> processJobPhases(userJobTuple))                .flatMap(this::saveUser)                .flatMap(this::phases);    }    public Mono<Pair<User, Job>> findUserByIdAndJobId(UUID userId, UUID jobId) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException(userId.toString())))                .flatMap(user -> Mono.justOrEmpty(user.getJobs().stream()                                .filter(job -> job.getJobId().equals(jobId))                                .findFirst())                        .switchIfEmpty(Mono.error(new JobNotFoundException(userId.toString(), jobId.toString())))                        .map(job -> of(user, job)));    }    public Mono<NextPhaseResponse> scheduleInterview(UUID userId,                                                     UUID jobId,                                                     UUID phaseId,                                                     ScheduleInterviewRequest request) {        return Mono.just(request)                .filter(req -> req.getScheduleTime() != null && !req.getScheduleTime().isEmpty())                .switchIfEmpty(Mono.error(new IllegalArgumentException("Schedule time is required.")))                .flatMap(req -> findUserByIdAndJobId(userId, jobId))                .flatMap(pair -> {                    Job job = pair.getValue();                    try {                        Instant interviewScheduleTime = DateTimeUtil.convertStringToInstant(request.getScheduleTime());                        Phase nextPhase = job.nextPhase();                        nextPhase.setInterviewScheduleTime(interviewScheduleTime);                        log.info("Successfully scheduled interview for job: {}, phase: {}, interviewScheduleTime: {}",                                jobId, nextPhase.getJobPhaseId(), interviewScheduleTime);                        job.setUpdatedAt(Instant.now());                        return userRepository.save(pair.getKey())                                .thenReturn(new NextPhaseResponse(nextPhase.getName(), nextPhase.getInterviewScheduleTime()));                    } catch (IllegalArgumentException e) {                        log.error("Invalid schedule time format for job: {}, phase: {}", jobId, phaseId, e);                        return Mono.error(new IllegalArgumentException("Invalid schedule time format."));                    }                });    }    public Mono<OfferResponse> offer(UUID userId, UUID jobId, OfferRequest request) {        return findUserByIdAndJobId(userId, jobId)                .flatMap(pair -> {                    Job job = pair.getValue();                    var currentPhase = job.currentPhase();                    updatePhaseStatus(currentPhase, request.getOfferType());                    pair.getKey().getInterviewStat().increaseOfferStatus(currentPhase.getStatusInfoEntity().getStatus());                    List<PhaseResponse> phases = job.getPhases().stream()                            .map(jobConverter::toPhaseResponse)                            .toList();                    int numberApplyCv = pair.getKey().getInterviewStat().getDailyProgress().getNumberApplyCv();                    JobPhasesStatusEntity jobPhasesStatus = pair.getKey().getJobPhasesStatus();                    job.setUpdatedAt(Instant.now());                    return userRepository.save(pair.getKey())                            .thenReturn(new OfferResponse(phases, jobConverter.createJobPhasesStatus(numberApplyCv, jobPhasesStatus)));                });    }    private Mono<PhaseResponse> handleAddPhase(User user, Job job, AddPhaseRequest request) {        log.info("Job found with jobId: [{}] for userId: [{}]", job.getJobId(), user.getUserId());        if (!job.getAvailablePhases().contains(request.getPhaseName())) {            throw new InvalidPhaseException(                    String.format("Phase [%s] not available for jobId [%s]",                            request.getPhaseName(), job.getJobId()));        }        var newPhase = createJobPhaseEntity(                request.getPhaseName(),                PhaseStatus.NOT_STARTED,                PhaseSubStatus.ACTION_REQUIRED,                "Next Stage",                "Proceed to next stage",                job.getPhases().size());        job.addPhaseInOrder(newPhase);        job.setUpdatedAt(Instant.now());        log.info("Added new phase [{}] to jobId [{}]", newPhase.getName(), job.getJobId());        return userRepository.save(user)                .map(updatedUser -> jobConverter.toPhaseResponse(newPhase));    }    private Mono<PhaseResponse> removePhase(User user, Job job, UUID phaseId) {        return Mono.defer(() -> job.getPhases().stream()                        .filter(phase -> phaseId.equals(phase.getJobPhaseId()))                        .findFirst()                        .map(Mono::just)                        .orElseGet(() -> Mono.error(new PhaseNotFoundException(phaseId.toString()))))                .flatMap(phase -> {                    PhaseStatus status = phase.getStatusInfoEntity().getStatus();                    if (status != PhaseStatus.NOT_STARTED) {                        return Mono.error(new InvalidPhaseException(status.toString()));                    }                    job.removePhase(phase);                    job.setUpdatedAt(Instant.now());                    log.info("Removed phase: [{}] from jobId: [{}]", phaseId, job.getJobId());                    return userRepository.save(user)                            .thenReturn(jobConverter.toPhaseResponse(phase));                });    }    private Phase createJobPhaseEntity(String phaseName,                                       PhaseStatus status,                                       PhaseSubStatus subStatus,                                       String stageButtonName,                                       String msgTooltip,                                       int currenPhaseSize) {        var newPhase = new Phase();        newPhase.setName(phaseName);        newPhase.setLastUpdatedDate(Instant.now());        PhaseStatusInfoEntity statusInfoEntity = new PhaseStatusInfoEntity();        statusInfoEntity.setStatus(status);        statusInfoEntity.setSubStatus(subStatus);        statusInfoEntity.setNextStageButtonName(stageButtonName);        statusInfoEntity.setMsgTooltip(msgTooltip);        newPhase.setStatusInfoEntity(statusInfoEntity);        newPhase.setOrderIndex(++currenPhaseSize);        return newPhase;    }    private Mono<Tuple2<User, Job>> findJob(User user, UUID jobId) {        return Mono.justOrEmpty(user.getJobs().stream()                        .filter(job -> job.getJobId().equals(jobId))                        .findFirst())                .map(job -> Tuples.of(user, job))                .switchIfEmpty(Mono.error(new JobNotFoundException(jobId.toString(), user.getUserId().toString())));    }    private Mono<Tuple2<User, Job>> saveUser(Tuple2<User, Job> userTuple) {        return userRepository.save(userTuple.getT1()).map(e -> Tuples.of(e, userTuple.getT2()));    }    private Mono<PhasesResponse> phases(Tuple2<User, Job> userTuple) {        ListJobs jobsResponse = jobConverter.toJobsResponse(userTuple.getT1());        Flux<PhaseResponse> phaseResponses = Flux.fromIterable(userTuple.getT2().getPhases())                .map(jobConverter::toPhaseResponse);        return phaseResponses.collectList()                .map(phaseList -> new PhasesResponse(                        phaseList,                        jobsResponse.getInterviewStats(),                        jobsResponse.getJobPhasesStatus()                ));    }    private Mono<Tuple2<User, Job>> processJobPhases(Tuple2<User, Job> userTuple) {        Phase currentPhase = userTuple.getT2().currentPhase();        Phase nextPhase = userTuple.getT2().nextPhase();        log.info("nextPhase: [{}]", nextPhase);        if (Objects.isNull(nextPhase)) {            throw new InvalidPhaseException("No nextPhase found for jobId: " + userTuple.getT2().getJobId());        }        phaseHandlers.stream()                .filter(handler -> handler.isApplicable(currentPhase))                .findAny()                .orElseThrow(() -> new InvalidPhaseException("No handler found for phase: " + currentPhase))                .handle(userTuple.getT1(), currentPhase, nextPhase);        userTuple.getT2().setUpdatedAt(Instant.now());        return Mono.just(userTuple);    }    private void updatePhaseStatus(Phase currentPhase, String offerType) {        PhaseStatus status = switch (offerType) {            case "Accepted" -> PhaseStatus.ACCEPTED;            case "Declined" -> PhaseStatus.DECLINED;            case "Rejected" -> PhaseStatus.REJECTED;            default -> throw new IllegalArgumentException("Invalid offer type: " + offerType);        };        currentPhase.getStatusInfoEntity().setStatus(status);        currentPhase.getStatusInfoEntity().setSubStatus(PhaseSubStatus.valueOf(status.name()));        currentPhase.getStatusInfoEntity().setMsgTooltip("Your journey has finished");    }}