package co.uk.offerland.job_track.application.usecases.phase;import co.uk.offerland.job_track.application.dto.NextPhaseResponse;import co.uk.offerland.job_track.application.dto.phase.AddPhaseRequest;import co.uk.offerland.job_track.application.dto.phase.PhaseResponse;import co.uk.offerland.job_track.application.dto.phase.PhasesResponse;import co.uk.offerland.job_track.application.dto.phase.ScheduleInterviewRequest;import co.uk.offerland.job_track.application.usecases.phase.handlers.PhaseHandler;import co.uk.offerland.job_track.domain.entity.JobPhase;import co.uk.offerland.job_track.domain.entity.PhaseStatus;import co.uk.offerland.job_track.domain.entity.PhaseSubStatus;import co.uk.offerland.job_track.domain.entity.nosql.Job;import co.uk.offerland.job_track.domain.entity.nosql.Phase;import co.uk.offerland.job_track.domain.entity.nosql.User;import co.uk.offerland.job_track.infrastructure.converter.JobConverter;import co.uk.offerland.job_track.infrastructure.exception.InvalidPhaseException;import co.uk.offerland.job_track.infrastructure.exception.JobNotFoundException;import co.uk.offerland.job_track.infrastructure.exception.UserNotFoundException;import co.uk.offerland.job_track.infrastructure.persistence.UserRepository;import co.uk.offerland.job_track.infrastructure.util.DateTimeUtil;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.tuple.Pair;import org.springframework.stereotype.Service;import reactor.core.publisher.Mono;import reactor.util.function.Tuple2;import reactor.util.function.Tuples;import java.time.Instant;import java.util.List;import java.util.UUID;import static org.apache.commons.lang3.tuple.Pair.of;@Slf4j@Service@RequiredArgsConstructorpublic class AddPhaseToJobUseCase {    private final UserRepository userRepository;    private final JobConverter jobConverter;    private final List<PhaseHandler> phaseHandlers;    public Mono<PhaseResponse> addPhase(UUID userId, UUID jobId, AddPhaseRequest request) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(                        new UserNotFoundException(String.format("User not found with userId:[%s]", userId))))                .flatMap(user -> user.getJobs().stream()                        .filter(job -> job.getJobId().equals(jobId))                        .findFirst()                        .map(job -> handleAddPhase(user, job, request))                        .orElseGet(() -> Mono.error(                                new JobNotFoundException(jobId.toString(), userId.toString())))                );    }    private Mono<PhaseResponse> handleAddPhase(User user, Job job, AddPhaseRequest request) {        log.info("Job found with jobId: [{}] for userId: [{}]", job.getJobId(), user.getUserId());        if (!job.getAvailablePhases().contains(request.getPhaseName())) {            throw new InvalidPhaseException(                    String.format("Phase [%s] not available for jobId [%s]",                            request.getPhaseName(), job.getJobId()));        }        var status = PhaseStatus.fromString(request.getStatus())                .orElseThrow(() -> new InvalidPhaseException(                        String.format("Invalid phase status: [%s]", request.getStatus())));        var newPhase = createJobPhaseEntity(request, status, job.getPhases().size());        job.addPhase(newPhase);        log.info("Added new phase [{}] to jobId [{}]", newPhase.getPhaseName(), job.getJobId());        return userRepository.save(user)                .map(updatedUser -> jobConverter.toPhaseResponse(newPhase));    }    public Mono<PhasesResponse> nextPhase(UUID userId, UUID jobId) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException(userId.toString())))                .flatMap(user -> findJob(user, jobId))                .flatMap(userJobTuple -> processJobPhases(userJobTuple))                .flatMap(this::saveUser)                .flatMap(this::phases);    }    private Phase createJobPhaseEntity(AddPhaseRequest request,                                       PhaseStatus status,                                       int currenPhaseSize) {        var newPhase = new Phase();        newPhase.setPhaseName(request.getPhaseName());        newPhase.setLastUpdatedDate(request.getDate());        newPhase.setStatus(status);        newPhase.setOrderIndex(++currenPhaseSize);        newPhase.setSubStatus(PhaseSubStatus.ACTION_REQUIRED);        return newPhase;    }    private Mono<Tuple2<User, Job>> findJob(User user, UUID jobId) {        return Mono.justOrEmpty(user.getJobs().stream()                        .filter(job -> job.getJobId().equals(jobId))                        .findFirst())                .map(job -> Tuples.of(user, job))                .switchIfEmpty(Mono.error(new JobNotFoundException(jobId.toString(), user.getUserId().toString())));    }    private Mono<Job> saveUser(Tuple2<User, Job> userTuple) {        return userRepository.save(userTuple.getT1())                .thenReturn(userTuple.getT2());    }    private Mono<PhasesResponse> phases(Job jobEntity) {        return Mono.just(new PhasesResponse(jobEntity.getPhases().stream()                .map(jobConverter::toPhaseResponse)                .toList()));    }    private Mono<Tuple2<User, Job>> processJobPhases(Tuple2<User, Job> userTuple) {        Phase currentPhase = userTuple.getT2().currentPhase();        Phase nextPhase = userTuple.getT2().nextPhase();        phaseHandlers.stream()                .filter(handler -> handler.isApplicable(currentPhase))                .findAny()                .ifPresent(phaseHandler -> phaseHandler.handle(userTuple.getT1(), currentPhase, nextPhase));        return Mono.just(userTuple);    }    public Mono<Pair<User, Job>> findUserByIdAndJobId(UUID userId, UUID jobId) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException(userId.toString())))                .flatMap(user -> Mono.justOrEmpty(user.getJobs().stream()                                .filter(job -> job.getJobId().equals(jobId))                                .findFirst())                        .switchIfEmpty(Mono.error(new JobNotFoundException(userId.toString(), jobId.toString())))                        .map(job -> of(user, job)));    }    public Mono<NextPhaseResponse> scheduleInterview(UUID userId,                                                     UUID jobId,                                                     UUID phaseId,                                                     ScheduleInterviewRequest request) {        return Mono.just(request)                .filter(req -> req.getScheduleTime() != null && !req.getScheduleTime().isEmpty())                .switchIfEmpty(Mono.error(new IllegalArgumentException("Schedule time is required.")))                .flatMap(req -> findUserByIdAndJobId(userId, jobId))                .flatMap(pair -> {                    Job job = pair.getValue();                    if (!JobPhase.APPLIED.getLabel().equals(job.currentPhase().getPhaseName())) {                        log.warn("Attempted to schedule interview for job: {}, phase: {} which is not APPLIED", jobId, job.currentPhase().getPhaseName());                        return Mono.error(new IllegalStateException("Interview scheduling is only allowed for APPLIED phase."));                    }                    try {                        Instant interviewScheduleTime = DateTimeUtil.convertStringToInstant(request.getScheduleTime());                        Phase nextPhase = job.nextPhase();                        nextPhase.setInterviewScheduleTime(interviewScheduleTime);                        log.info("Successfully scheduled interview for job: {}, phase: {}, interviewScheduleTime: {}",                                jobId, nextPhase.getJobPhaseId(), interviewScheduleTime);                       return userRepository.save(pair.getKey())                                .thenReturn(new NextPhaseResponse(nextPhase.getPhaseName(), nextPhase.getInterviewScheduleTime()));                    } catch (IllegalArgumentException e) {                        log.error("Invalid schedule time format for job: {}, phase: {}", jobId, phaseId, e);                        return Mono.error(new IllegalArgumentException("Invalid schedule time format."));                    }                });    }}//    public AddPhasesResponse offer(UUID userId, UUID jobId, OfferRequest request) {//        var jobEntity = jobQueryService.getJobByUserIdAndJobId(userId, jobId);//        var currentPhase = jobEntity.currentPhase();//        if (currentPhase.getPhaseName().equals(JobPhase.OFFER_STATUS.getLabel())) {//            currentPhase.setActiveStatus(request.getOfferAction());//            currentPhase.setLastUpdatedDate(Instant.now());//            if (request.getOfferAction().equals("Accept Offer")) {//                currentPhase.setStatus(JobPhaseStatus.COMPLETED);//            } else if (request.getOfferAction().equals("Decline Offer")) {//                currentPhase.setStatus(JobPhaseStatus.DECLINED);//            } else if (request.getOfferAction().equals("Reject Offer")) {//                currentPhase.setStatus(JobPhaseStatus.REJECTED);//            }//            jobRepository.save(jobEntity);//        }//        List<PhaseResponse> addPhaseResponses =//            jobEntity.getPhases().stream()//                .map(phase -> jobConverter.toResponse(phase))//                .toList();////        return new AddPhasesResponse(addPhaseResponses);//        return null;//    }//}