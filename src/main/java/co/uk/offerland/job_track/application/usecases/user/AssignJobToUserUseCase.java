package co.uk.offerland.job_track.application.usecases.user;import co.uk.offerland.job_track.application.dto.user.*;import co.uk.offerland.job_track.domain.entity.JobPhase;import co.uk.offerland.job_track.domain.entity.JobPhaseStatus;import co.uk.offerland.job_track.domain.entity.nosql.JobEntity;import co.uk.offerland.job_track.domain.entity.nosql.JobPhaseEntity;import co.uk.offerland.job_track.infrastructure.converter.JobConverter;import co.uk.offerland.job_track.infrastructure.exception.JobAlreadyExistsException;import co.uk.offerland.job_track.infrastructure.exception.JobNotFoundException;import co.uk.offerland.job_track.infrastructure.exception.UserNotFoundException;import co.uk.offerland.job_track.infrastructure.persistence.UserRepository;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.jetbrains.annotations.NotNull;import org.springframework.stereotype.Service;import reactor.core.publisher.Mono;import reactor.core.scheduler.Schedulers;import java.time.Instant;import java.util.UUID;@Slf4j@Service@RequiredArgsConstructorpublic class AssignJobToUserUseCase {    public static final String ACTION_REQUIRED_MSG = "Action required";    public static final String WAIT_RESPONSE_MSG = "Wait Response";    public static final String TIME_FOR_PREPARE_MSG = "Time For Prepare";    public static final String DONE = "Done";    private final UserRepository userRepository;    private final JobConverter jobConverter;    public Mono<CreateJobResponse> addJobToUser(UUID userId, CreateJobRequest request) {        return userRepository.findByUserId(userId)                .subscribeOn(Schedulers.boundedElastic())                .switchIfEmpty(Mono.error(new UserNotFoundException("User not found id:" + userId)))                .flatMap(foundUser -> Mono.just(foundUser)                        .flatMap(user -> {                            if (user.getJobs().stream().anyMatch(job -> job.getLink().equals(request.getLink()))) {                                return Mono.error(new JobAlreadyExistsException(                                        String.format("Job entity already exists, link: [%s], userId: [%s]", request.getLink(), userId)));                            }                            return Mono.just(user);                        }))                .flatMap(foundUser -> {                    JobEntity newJobEntity = jobConverter.toEntity(request, Instant.now());                    foundUser.getJobs().add(newJobEntity);                    newJobEntity.addPhase(createWishlistPhase());                    newJobEntity.addPhase(createAppliedPhase());                    return userRepository.save(foundUser)                            .map(user -> jobConverter.toResponse(newJobEntity));                }).onErrorResume(JobAlreadyExistsException.class, Mono::error);    }    private JobPhaseEntity createAppliedPhase() {        var appliedPhase = new JobPhaseEntity();        appliedPhase.setStatus(JobPhaseStatus.IN_PROGRESS);        appliedPhase.setPhaseName(JobPhase.APPLIED.getLabel());        appliedPhase.setOrderIndex(2);        appliedPhase.setLastUpdatedDate(Instant.now());        appliedPhase.setActiveStatus(ACTION_REQUIRED_MSG);        return appliedPhase;    }    private JobPhaseEntity createWishlistPhase() {        var wishlistPhase = new JobPhaseEntity();        wishlistPhase.setStatus(JobPhaseStatus.COMPLETED);        wishlistPhase.setPhaseName(JobPhase.SAVED.getLabel());        wishlistPhase.setOrderIndex(1);        wishlistPhase.setLastUpdatedDate(Instant.now());        wishlistPhase.setActiveStatus(DONE);        return wishlistPhase;    }    public Mono<ListJobs> getJobsByUserId(UUID userId) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException("User not found id:" + userId)))                .flatMap(user -> Mono.just(user.getJobs()))                .map(jobConverter::toResponse)                .onErrorResume(UserNotFoundException.class, Mono::error);    }    public Mono<JobEntity> getJobByUserAndJobId(UUID userId, UUID jobId) {        return userRepository.findByUserIdAndJobsJobId(userId, jobId)                .switchIfEmpty(Mono.error(new UserNotFoundException("User not found id:" + userId)))                .flatMap(user -> user.getJobs().stream()                        .filter(job -> job.getJobId().equals(jobId))                        .findFirst()                        .map(Mono::just)                        .orElse(Mono.empty()));    }    public ContactPersonResponse addContactPerson(UUID userId, UUID jobId, ContactPersonRequest request) {//        if (StringUtils.isBlank(request.getFirstName())) {//            throw new IllegalArgumentException("Contact first name can not be empty");//        }////        var jobEntity = getJobByUserAndJobId(userId, jobId);//        var contactPerson = jobEntity.getContactPerson();////        if (contactPerson == null) {//            contactPerson = new ContactPersonEntity();//            contactPerson.setJob(jobEntity);//        }////        contactPerson.setFirstName(request.getFirstName());//        if (StringUtils.isNotBlank(request.getLastName())) {//            contactPerson.setLastName(request.getLastName());//        }//        if (StringUtils.isNotBlank(request.getEmail())) {//            contactPerson.setEmail(request.getEmail());//        }//        if (StringUtils.isNotBlank(request.getPhone())) {//            contactPerson.setPhone(request.getPhone());//        }//        if (StringUtils.isNotBlank(request.getLinkedin())) {//            contactPerson.setLinkedin(request.getLinkedin());//        }////        jobEntity.setContactPerson(contactPerson);////        var savedJobEntity = jobRepository.save(jobEntity);//        log.info("Added/Updated contact person for jobId:{} userId:{}", jobId, userId);//////        return jobConverter.toContactPersonResponse(savedJobEntity);        return null;    }    public Mono<Void> addJobNote(UUID userId, UUID jobId, JobNoteRequest request) {        return userRepository.findByUserIdAndJobsJobId(userId, jobId)                .switchIfEmpty(Mono.error(new JobNotFoundException("Job not found id:" + jobId)))                .flatMap(user -> {                    user.getJobs().stream()                            .filter(job -> job.getJobId().equals(jobId))                            .findFirst()                            .ifPresent(job -> job.setNotes(request.getNotes())); // Update notes                    return userRepository.save(user).then(); // Save the updated user                })                .doOnSuccess(v -> log.info("Added job note for jobId:{} userId:{}", jobId, userId));    }}