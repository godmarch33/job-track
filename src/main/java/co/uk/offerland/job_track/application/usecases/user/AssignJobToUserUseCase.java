package co.uk.offerland.job_track.application.usecases.user;import co.uk.offerland.job_track.application.dto.phase.InterviewNoteResponse;import co.uk.offerland.job_track.application.dto.user.*;import co.uk.offerland.job_track.domain.entity.ContactPerson;import co.uk.offerland.job_track.domain.entity.JobPhase;import co.uk.offerland.job_track.domain.entity.PhaseStatus;import co.uk.offerland.job_track.domain.entity.PhaseSubStatus;import co.uk.offerland.job_track.domain.entity.nosql.*;import co.uk.offerland.job_track.infrastructure.converter.JobConverter;import co.uk.offerland.job_track.infrastructure.exception.JobAlreadyExistsException;import co.uk.offerland.job_track.infrastructure.exception.JobNotFoundException;import co.uk.offerland.job_track.infrastructure.exception.UserNotFoundException;import co.uk.offerland.job_track.infrastructure.persistence.UserRepository;import io.micrometer.common.util.StringUtils;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.tuple.Pair;import org.springframework.stereotype.Service;import reactor.core.publisher.Mono;import java.time.Instant;import java.util.UUID;import static org.apache.commons.lang3.tuple.Pair.*;@Slf4j@Service@RequiredArgsConstructorpublic class AssignJobToUserUseCase {    private final UserRepository userRepository;    private final JobConverter jobConverter;    public Mono<CreateJobResponse> addJob(UUID userId, CreateJobRequest request) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException(userId.toString())))                .flatMap(foundUser -> Mono.just(foundUser)                        .flatMap(user -> {                            if (user.getJobs().stream().anyMatch(job -> job.getJobUrl().equals(request.getJobUrl()))) {                                return Mono.error(new JobAlreadyExistsException(userId.toString(), request.getJobUrl()));                            }                            return Mono.just(user);                        }))                .flatMap(foundUser -> {                    Job newJobEntity = jobConverter.toEntity(request, Instant.now());                    foundUser.getJobs().add(newJobEntity);                    foundUser.getInterviewStat().getDailyProgress().updateCounter();                    if(request.getPhase().equals(JobPhase.APPLIED.getLabel())){                        newJobEntity.addPhase(createSavedPhase(PhaseStatus.COMPLETED, PhaseSubStatus.DONE));                        var msgTooltip = "Waiting for a response from HR. You can schedule an interview, edit notes, or add a contact person to assist with the process once you receive more details. Move to the next stage after you get a response";                        newJobEntity.addPhase(createAppliedPhase(PhaseStatus.IN_PROGRESS, PhaseSubStatus.WAIT_RESPONSE,"Proceed to Next Interview Stage", msgTooltip));                    } else {                        newJobEntity.addPhase(createSavedPhase(PhaseStatus.IN_PROGRESS, PhaseSubStatus.ACTION_REQUIRED));                        var msgTooltip = "Press 'Mark as Applied' to confirm that you have applied for this vacancy";                        newJobEntity.addPhase(createAppliedPhase(PhaseStatus.NOT_STARTED, PhaseSubStatus.NONE,"Mark as applied", msgTooltip));                    }                    return userRepository.save(foundUser)                            .map(user -> jobConverter.toResponse(newJobEntity));                });    }    public Mono<ListJobs> getJobsByUserId(UUID userId) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException("User not found id:" + userId)))                .flatMap(user -> {                    user.getInterviewStat().getDailyProgress().releaseNextDayCounter();                    return userRepository.save(user);                })                .map(jobConverter::toJobsResponse)                .onErrorResume(UserNotFoundException.class, Mono::error);    }    public Mono<Pair<User, Job>> findUserByIdAndJobId(UUID userId, UUID jobId) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException(userId.toString())))                .flatMap(user -> Mono.justOrEmpty(user.getJobs().stream()                                .filter(job -> job.getJobId().equals(jobId))                                .findFirst())                        .switchIfEmpty(Mono.error(new JobNotFoundException(userId.toString(), jobId.toString())))                        .map(job -> of(user, job)));    }    public Mono<ContactPersonResponse> addContactPerson(UUID userId, UUID jobId, ContactPersonRequest request) {        return findUserByIdAndJobId(userId, jobId)                .flatMap(result -> {                    Job job = result.getValue();                    job.setContactPerson(createOrUpdateContactDetails(request, job.getContactPerson()));                    return userRepository.save(result.getKey())                            .map(user -> jobConverter.toContactPersonResponse(user, jobId));                })                .doOnSuccess(v -> log.info("Added/Updated contact person for jobId:{} userId:{}", jobId, userId));    }    private Phase createAppliedPhase(PhaseStatus phaseStatus, PhaseSubStatus phaseSubStatus,String buttonName, String msgTooltip) {        var appliedPhase = new Phase();        var statusInfoEntity = new PhaseStatusInfoEntity();        statusInfoEntity.setStatus(phaseStatus);        statusInfoEntity.setSubStatus(phaseSubStatus);        statusInfoEntity.setNextStageButtonName(buttonName);        statusInfoEntity.setMsgTooltip(msgTooltip);        appliedPhase.setStatusInfoEntity(statusInfoEntity);        appliedPhase.setPhaseName(JobPhase.APPLIED.getLabel());        appliedPhase.setOrderIndex(2);        appliedPhase.setLastUpdatedDate(Instant.now());        return appliedPhase;    }    private Phase createSavedPhase(PhaseStatus phaseStatus, PhaseSubStatus subStatus) {        var savedPhase = new Phase();        var statusInfoEntity = new PhaseStatusInfoEntity();        statusInfoEntity.setStatus(phaseStatus);        statusInfoEntity.setSubStatus(subStatus);        statusInfoEntity.setNextStageButtonName("Save");        savedPhase.setStatusInfoEntity(statusInfoEntity);        savedPhase.setPhaseName(JobPhase.SAVED.getLabel());        savedPhase.setOrderIndex(1);        savedPhase.setLastUpdatedDate(Instant.now());        return savedPhase;    }    private ContactPerson createOrUpdateContactDetails(ContactPersonRequest request, ContactPerson contactPerson) {        if (contactPerson == null) {            contactPerson = new ContactPerson();        }        if (!StringUtils.isBlank(request.getFullName())) {            contactPerson.setFullName(request.getFullName());        }        if (!StringUtils.isBlank(request.getEmail())) {            contactPerson.setEmail(request.getEmail());        }        if (!StringUtils.isBlank(request.getPhone())) {            contactPerson.setPhone(request.getPhone());        }        if (!StringUtils.isBlank(request.getLinkedin())) {            contactPerson.setLinkedin(request.getLinkedin());        }        if (!StringUtils.isBlank(request.getCommunicationChannel())) {            contactPerson.setCommunicationChannel(request.getCommunicationChannel());        }        return contactPerson;    }    public Mono<InterviewNoteResponse> addInterviewNote(UUID userId, UUID jobId, JobNoteRequest request) {        return findUserByIdAndJobId(userId, jobId)                .flatMap(result -> {                    var job = result.getValue();                    InterviewNote notes = new InterviewNote(request.getNotes());                    job.setNotes(notes);                    return userRepository.save(result.getKey())                            .map(user -> new InterviewNoteResponse(notes.getNotes()));                })                .doOnSuccess(v -> log.info("Added job note for jobId:[{}] userId:[{}]", jobId, userId));    }}