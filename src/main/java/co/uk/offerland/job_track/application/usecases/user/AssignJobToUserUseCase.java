package co.uk.offerland.job_track.application.usecases.user;import co.uk.offerland.job_track.application.dto.job.CreateJobRequest;import co.uk.offerland.job_track.application.dto.job.CreateJobResponse;import co.uk.offerland.job_track.application.dto.job.JobNoteRequest;import co.uk.offerland.job_track.application.dto.job.ListJobs;import co.uk.offerland.job_track.application.dto.phase.ChangeSalaryResponse;import co.uk.offerland.job_track.application.dto.phase.InterviewNoteResponse;import co.uk.offerland.job_track.application.dto.user.*;import co.uk.offerland.job_track.domain.entity.ContactPerson;import co.uk.offerland.job_track.domain.entity.PhaseName;import co.uk.offerland.job_track.domain.entity.PhaseStatus;import co.uk.offerland.job_track.domain.entity.PhaseSubStatus;import co.uk.offerland.job_track.domain.entity.nosql.*;import co.uk.offerland.job_track.infrastructure.ai.AIAssistant;import co.uk.offerland.job_track.infrastructure.converter.JobConverter;import co.uk.offerland.job_track.infrastructure.exception.JobAlreadyExistsException;import co.uk.offerland.job_track.infrastructure.exception.JobNotFoundException;import co.uk.offerland.job_track.infrastructure.exception.UserNotFoundException;import co.uk.offerland.job_track.infrastructure.persistence.UserRepository;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.tuple.Pair;import org.springframework.stereotype.Service;import reactor.core.publisher.Mono;import reactor.core.scheduler.Schedulers;import java.time.Instant;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.UUID;import static co.uk.offerland.job_track.application.usecases.phase.handlers.AppliedPhaseHandler.*;import static org.apache.commons.lang3.tuple.Pair.*;@Slf4j@Service@RequiredArgsConstructorpublic class AssignJobToUserUseCase {    private final UserRepository userRepository;    private final JobConverter jobConverter;    private final AIAssistant ragAssistant;    public Mono<CreateJobResponse> addJob(UUID userId, CreateJobRequest request) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException(userId.toString())))                .flatMap(foundUser -> Mono.just(foundUser)                        .flatMap(user -> {                            if (user.getJobs().stream().anyMatch(job -> job.getJobUrl().equals(request.getJobUrl()))) {                                return Mono.error(new JobAlreadyExistsException(userId.toString(), request.getJobUrl()));                            }                            return Mono.just(user);                        }))                .flatMap(user ->                        Mono.fromCallable(() -> ragAssistant.findJobInterviewPhases("company:" + request.getCompany() + ", position:" + request.getTitle() + " location:" + request.getLocation()))                                .subscribeOn(Schedulers.boundedElastic())                                .flatMap(interviewJson -> Mono.just(parseInterviewDetails(interviewJson)))                                .flatMap(interviewPhases -> Mono.just(Pair.of(user, interviewPhases))))                .flatMap(userPair -> {                    var newJobEntity = jobConverter.toEntity(request, Instant.now());                    userPair.getKey().getJobs().add(newJobEntity);                    userPair.getKey().getInterviewStat().getDailyProgress().updateCounter();                    if (request.getPhase().equals(PhaseName.APPLIED.getLabel())) {                        newJobEntity.addPhase(createSavedPhase(PhaseStatus.COMPLETED, PhaseSubStatus.DONE));                        newJobEntity.addPhase(createAppliedPhase(PhaseStatus.IN_PROGRESS, PhaseSubStatus.PENDING_HR_REPLY, PROCEED_TO_NEXT_INTERVIEW_STAGE, MSG_TOOLTIP_WAIT_RESPONSE));                    } else {                        newJobEntity.addPhase(createSavedPhase(PhaseStatus.COMPLETED, PhaseSubStatus.DONE));                        newJobEntity.addPhase(createAppliedPhase(PhaseStatus.IN_PROGRESS, PhaseSubStatus.ACTION_REQUIRED, MARK_AS_APPLIED, MARK_AS_APPLIED_TOOLTIP));                    }                    buildPhasesFlow(userId, userPair, newJobEntity);                    log.info("Added phase newJobEntity:[{}]", newJobEntity);                    userPair.getKey().getInterviewStat().increaseSaved();                    return userRepository.save(userPair.getKey())                            .map(user -> jobConverter.toResponse(newJobEntity));                });    }    private void buildPhasesFlow(UUID userId, Pair<User, List<PhaseName>> userPair, Job newJobEntity) {        List<PhaseName> phases = userPair.getValue();        log.info("Adding phase {} to user {}", phases, userId);        int lastAddedOrderIndex = newJobEntity.currentPhase().getOrderIndex();        for (int i = 0; i < phases.size(); i++) {            var phase = new Phase();            addPhases(phase, phases, i, lastAddedOrderIndex, newJobEntity);        }        if (!phases.contains(PhaseName.OFFER_STATUS)) {            addOfferPhase(newJobEntity);        }    }    private void addOfferPhase(Job newJobEntity) {        var phase = new Phase();        var statusInfoEntity = new PhaseStatusInfoEntity();        statusInfoEntity.setStatus(PhaseStatus.NOT_STARTED);        statusInfoEntity.setSubStatus(PhaseSubStatus.WAIT_OFFER_DESICION);        statusInfoEntity.setNextStageButtonName("none");        statusInfoEntity.setMsgTooltip("Wait response from hr");        phase.setStatusInfoEntity(statusInfoEntity);        phase.setPhaseName(PhaseName.OFFER_STATUS.getLabel());        phase.setOrderIndex(newJobEntity.getPhases().size() + 1);        phase.setLastUpdatedDate(Instant.now());        newJobEntity.addPhase(phase);    }    private void addPhases(Phase phase, List<PhaseName> phases, int i, int lastAddedOrderIndex, Job newJobEntity) {        var statusInfoEntity = new PhaseStatusInfoEntity();        statusInfoEntity.setStatus(PhaseStatus.NOT_STARTED);        statusInfoEntity.setSubStatus(PhaseSubStatus.TIME_FOR_PREPARE);        statusInfoEntity.setNextStageButtonName("Next Stage");        statusInfoEntity.setMsgTooltip("Prepare for the next phase.");        phase.setStatusInfoEntity(statusInfoEntity);        phase.setPhaseName(phases.get(i).getLabel());        phase.setOrderIndex(lastAddedOrderIndex + i + 1);        phase.setLastUpdatedDate(Instant.now());        newJobEntity.addPhase(phase);    }    private List<PhaseName> parseInterviewDetails(String json) {        List<PhaseName> phaseNames = new ArrayList<>();        try {            ObjectMapper mapper = new ObjectMapper();            JsonNode node = mapper.readTree(json);            if (node.has("phases") && node.get("phases").isArray()) {                for (JsonNode phaseNode : node.get("phases")) {                    String phaseName = phaseNode.asText();                    try {                        PhaseName phase = PhaseName.fromCode(phaseName);                        phaseNames.add(phase);                    } catch (IllegalArgumentException e) {                        log.warn("Unrecognized phase: {}", phaseName);                    }                }            }        } catch (Exception e) {            log.error("Failed to parse interview details: {}", e.getMessage(), e);            return Collections.emptyList();        }        log.info("Interview details: {}", json);        log.info("Interview parsed: {}", phaseNames);        return phaseNames;    }    public Mono<ListJobs> getJobsByUserId(UUID userId) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException("User not found id:" + userId)))                .flatMap(user -> {                    user.getInterviewStat().getDailyProgress().releaseNextDayCounter();                    return userRepository.save(user);                })                .map(jobConverter::toJobsResponse)                .onErrorResume(UserNotFoundException.class, Mono::error);    }    public Mono<Pair<User, Job>> findUserByIdAndJobId(UUID userId, UUID jobId) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException(userId.toString())))                .flatMap(user -> Mono.justOrEmpty(user.getJobs().stream()                                .filter(job -> job.getJobId().equals(jobId))                                .findFirst())                        .switchIfEmpty(Mono.error(new JobNotFoundException(userId.toString(), jobId.toString())))                        .map(job -> of(user, job)));    }    public Mono<ContactPersonResponse> addContactPerson(UUID userId, UUID jobId, ContactPersonRequest request) {        return findUserByIdAndJobId(userId, jobId)                .flatMap(result -> {                    Job job = result.getValue();                    var contactDetails = createContactDetails(request);                    job.getContactPersons().add(contactDetails);                    job.setUpdatedAt(Instant.now());                    return userRepository.save(result.getKey())                            .thenReturn(jobConverter.toContactPersonResponse(contactDetails));                })                .doOnSuccess(v -> log.info("Added/Updated contact person for jobId:{} userId:{}", jobId, userId));    }    private Phase createAppliedPhase(PhaseStatus phaseStatus, PhaseSubStatus phaseSubStatus, String buttonName, String msgTooltip) {        var appliedPhase = new Phase();        var statusInfoEntity = new PhaseStatusInfoEntity();        statusInfoEntity.setStatus(phaseStatus);        statusInfoEntity.setSubStatus(phaseSubStatus);        statusInfoEntity.setNextStageButtonName(buttonName);        statusInfoEntity.setMsgTooltip(msgTooltip);        appliedPhase.setStatusInfoEntity(statusInfoEntity);        appliedPhase.setPhaseName(PhaseName.APPLIED.getLabel());        appliedPhase.setOrderIndex(2);        appliedPhase.setLastUpdatedDate(Instant.now());        return appliedPhase;    }    private Phase createSavedPhase(PhaseStatus phaseStatus, PhaseSubStatus subStatus) {        var savedPhase = new Phase();        var statusInfoEntity = new PhaseStatusInfoEntity();        statusInfoEntity.setStatus(phaseStatus);        statusInfoEntity.setSubStatus(subStatus);        statusInfoEntity.setNextStageButtonName("Save");        statusInfoEntity.setMsgTooltip("proceed to applied");        savedPhase.setStatusInfoEntity(statusInfoEntity);        savedPhase.setPhaseName(PhaseName.SAVED.getLabel());        savedPhase.setOrderIndex(1);        savedPhase.setLastUpdatedDate(Instant.now());        return savedPhase;    }    private ContactPerson createContactDetails(ContactPersonRequest request) {        return ContactPerson.builder()                .communicationChannel(request.getCommunicationChannel())                .linkedin(request.getLinkedin())                .phone(request.getPhone())                .email(request.getEmail())                .fullName(request.getFullName())                .build();    }    public Mono<InterviewNoteResponse> addInterviewNote(UUID userId, UUID jobId, JobNoteRequest request) {        return findUserByIdAndJobId(userId, jobId)                .flatMap(result -> {                    var job = result.getValue();                    InterviewNote notes = new InterviewNote(request.getNotes());                    job.setNotes(notes);                    job.setUpdatedAt(Instant.now());                    return userRepository.save(result.getKey())                            .map(user -> new InterviewNoteResponse(notes.getNotes()));                })                .doOnSuccess(v -> log.info("Added job note for jobId:[{}] userId:[{}]", jobId, userId));    }    public Mono<ChangeSalaryResponse> changeSalary(UUID userId, UUID jobId, ChangeSalaryRequest request) {        return findUserByIdAndJobId(userId, jobId)                .flatMap(result -> {                    var job = result.getValue();                    job.setJobSalary(request.getAmount() + " " + request.getCurrency());                    job.setUpdatedAt(Instant.now());                    return userRepository.save(result.getKey())                            .map(user -> new ChangeSalaryResponse(request.getAmount(), request.getCurrency()));                })                .doOnSuccess(v -> log.info("Change salary for jobId:[{}] userId:[{}]", jobId, userId));    }}