package co.uk.offerland.job_track.application.usecases.user;import co.uk.offerland.job_track.application.dto.user.*;import co.uk.offerland.job_track.domain.entity.ContactPerson;import co.uk.offerland.job_track.domain.entity.JobPhase;import co.uk.offerland.job_track.domain.entity.PhaseStatus;import co.uk.offerland.job_track.domain.entity.PhaseSubStatus;import co.uk.offerland.job_track.domain.entity.nosql.Job;import co.uk.offerland.job_track.domain.entity.nosql.Phase;import co.uk.offerland.job_track.domain.entity.nosql.User;import co.uk.offerland.job_track.infrastructure.converter.JobConverter;import co.uk.offerland.job_track.infrastructure.exception.JobAlreadyExistsException;import co.uk.offerland.job_track.infrastructure.exception.JobNotFoundException;import co.uk.offerland.job_track.infrastructure.exception.UserNotFoundException;import co.uk.offerland.job_track.infrastructure.persistence.UserRepository;import io.micrometer.common.util.StringUtils;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.tuple.Pair;import org.springframework.stereotype.Service;import org.yaml.snakeyaml.util.Tuple;import reactor.core.publisher.Mono;import reactor.core.scheduler.Schedulers;import reactor.util.function.Tuple2;import java.time.Instant;import java.util.UUID;import static org.apache.commons.lang3.tuple.Pair.*;@Slf4j@Service@RequiredArgsConstructorpublic class AssignJobToUserUseCase {    private final UserRepository userRepository;    private final JobConverter jobConverter;    public Mono<CreateJobResponse> addJob(UUID userId, CreateJobRequest request) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException(userId.toString())))                .flatMap(foundUser -> Mono.just(foundUser)                        .flatMap(user -> {                            if (user.getJobs().stream().anyMatch(job -> job.getJobUrl().equals(request.getJobUrl()))) {                                return Mono.error(new JobAlreadyExistsException(userId.toString(), request.getJobUrl()));                            }                            return Mono.just(user);                        }))                .flatMap(foundUser -> {                    Job newJobEntity = jobConverter.toEntity(request, Instant.now());                    foundUser.getJobs().add(newJobEntity);                    newJobEntity.addPhase(createSavedPhase());                    newJobEntity.addPhase(createAppliedPhase());                    foundUser.getInterviewStat().increaseSavedAndProgress();                    return userRepository.save(foundUser)                            .map(user -> jobConverter.toResponse(newJobEntity));                });    }    public Mono<ListJobs> getJobsByUserId(UUID userId) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException("User not found id:" + userId)))                .flatMap(user -> {                    user.getInterviewStat().getDailyProgress().releaseNextDayCounter();                    return userRepository.save(user);                })                .map(jobConverter::toJobsResponse)                .onErrorResume(UserNotFoundException.class, Mono::error);    }    public Mono<Pair<User, Job>> findUserByIdAndJobId(UUID userId, UUID jobId) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException(userId.toString())))                .flatMap(user -> Mono.justOrEmpty(user.getJobs().stream()                                .filter(job -> job.getJobId().equals(jobId))                                .findFirst())                        .switchIfEmpty(Mono.error(new JobNotFoundException(userId.toString(), jobId.toString())))                        .map(job -> of(user, job)));    }    public Mono<ContactPersonResponse> addContactPerson(UUID userId, UUID jobId, ContactPersonRequest request) {        return findUserByIdAndJobId(userId, jobId)                .flatMap(result -> {                    Job job = result.getValue();                    job.setContactPerson(createOrUpdateContactDetails(request, job.getContactPerson()));                    return userRepository.save(result.getKey())                            .map(user -> jobConverter.toContactPersonResponse(user, jobId));                })                .doOnSuccess(v -> log.info("Added/Updated contact person for jobId:{} userId:{}", jobId, userId));    }    private Phase createAppliedPhase() {        var appliedPhase = new Phase();        appliedPhase.setStatus(PhaseStatus.IN_PROGRESS);        appliedPhase.setPhaseName(JobPhase.APPLIED.getLabel());        appliedPhase.setOrderIndex(2);        appliedPhase.setLastUpdatedDate(Instant.now());        appliedPhase.setSubStatus(PhaseSubStatus.ACTION_REQUIRED);        return appliedPhase;    }    private Phase createSavedPhase() {        var savedPhase = new Phase();        savedPhase.setStatus(PhaseStatus.COMPLETED);        savedPhase.setPhaseName(JobPhase.SAVED.getLabel());        savedPhase.setOrderIndex(1);        savedPhase.setLastUpdatedDate(Instant.now());        savedPhase.setSubStatus(PhaseSubStatus.DONE);        return savedPhase;    }    private ContactPerson createOrUpdateContactDetails(ContactPersonRequest request, ContactPerson contactPerson) {        if (contactPerson == null) {            contactPerson = new ContactPerson();        }        if (!StringUtils.isBlank(request.getFullName())) {            contactPerson.setFullName(request.getFullName());        }        if (!StringUtils.isBlank(request.getEmail())) {            contactPerson.setEmail(request.getEmail());        }        if (!StringUtils.isBlank(request.getPhone())) {            contactPerson.setPhone(request.getPhone());        }        if (!StringUtils.isBlank(request.getLinkedin())) {            contactPerson.setLinkedin(request.getLinkedin());        }        return contactPerson;    }    public Mono<Void> addJobNote(UUID userId, UUID jobId, JobNoteRequest request) {        return findUserByIdAndJobId(userId, jobId)                .flatMap(result -> {                    var job = result.getValue();                    job.setNotes(request.getNotes());                    return userRepository.save(result.getKey()).then();                })                .doOnSuccess(v -> log.info("Added job note for jobId:[{}] userId:[{}]", jobId, userId));    }}