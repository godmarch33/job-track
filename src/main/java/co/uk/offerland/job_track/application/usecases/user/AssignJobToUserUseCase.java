package co.uk.offerland.job_track.application.usecases.user;import java.time.Instant;import java.util.List;import java.util.UUID;import co.uk.offerland.job_track.domain.entity.UserEntity;import co.uk.offerland.job_track.infrastructure.persistence.r2dbc.UserR2dbcRepository;import org.apache.commons.lang3.StringUtils;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import co.uk.offerland.job_track.application.dto.user.ContactPersonRequest;import co.uk.offerland.job_track.application.dto.user.ContactPersonResponse;import co.uk.offerland.job_track.application.dto.user.CreateJobRequest;import co.uk.offerland.job_track.application.dto.user.CreateJobResponse;import co.uk.offerland.job_track.application.dto.user.JobNoteRequest;import co.uk.offerland.job_track.application.dto.user.ListJobs;import co.uk.offerland.job_track.domain.entity.ContactPersonEntity;import co.uk.offerland.job_track.domain.entity.JobEntity;import co.uk.offerland.job_track.domain.entity.JobPhase;import co.uk.offerland.job_track.domain.entity.JobPhaseEntity;import co.uk.offerland.job_track.domain.entity.JobPhaseStatus;import co.uk.offerland.job_track.infrastructure.converter.JobConverter;import co.uk.offerland.job_track.infrastructure.exception.JobAlreadyExistsException;import co.uk.offerland.job_track.infrastructure.exception.JobNotFoundException;import co.uk.offerland.job_track.infrastructure.exception.UserNotFoundException;import co.uk.offerland.job_track.infrastructure.persistence.jdbc.JobJdbcRepository;import co.uk.offerland.job_track.infrastructure.persistence.jdbc.UserJdbcRepository;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import reactor.core.publisher.Flux;import reactor.core.publisher.Mono;@Slf4j@Service@RequiredArgsConstructorpublic class AssignJobToUserUseCase {    public static final String ACTION_REQUIRED_MSG = "Action required";    public static final String WAIT_RESPONSE_MSG = "Wait Response";    public static final String TIME_FOR_PREPARE_MSG = "Time For Prepare";    private final UserJdbcRepository userRepository;    private final UserR2dbcRepository userR2dbcRepository;    private final JobJdbcRepository jobRepository;    private final JobConverter jobConverter;    @Transactional    public CreateJobResponse addJobToUser(UUID userId, CreateJobRequest request) {        var foundUser = userRepository.findById(userId)            .orElseThrow(() -> new UserNotFoundException("User not found"));        foundUser.getJobs().stream()            .filter(job -> job.getLink().equals(request.getLink()))            .findFirst()            .ifPresent(job -> {                throw new JobAlreadyExistsException(                    String.format("Job entity already exists, link: [%s], userId: [%s]", request.getLink(), userId)                );            });        JobEntity jobEntityToSave = jobConverter.toEntity(request, foundUser, Instant.now());        JobPhaseEntity wishlistPhase = new JobPhaseEntity();        wishlistPhase.setLastUpdatedDate(Instant.now());        wishlistPhase.setJob(jobEntityToSave);        wishlistPhase.setStatus(JobPhaseStatus.COMPLETED);        wishlistPhase.setPhaseName(JobPhase.SAVED.getLabel());        wishlistPhase.setOrderIndex(1);        wishlistPhase.setActiveStatus("Done");        jobEntityToSave.getPhases().add(wishlistPhase);        JobPhaseEntity appliedPhase = new JobPhaseEntity();        appliedPhase.setJob(jobEntityToSave);        appliedPhase.setStatus(JobPhaseStatus.IN_PROGRESS);        appliedPhase.setPhaseName(JobPhase.APPLIED.getLabel());        appliedPhase.setOrderIndex(2);        appliedPhase.setActiveStatus(ACTION_REQUIRED_MSG);        jobEntityToSave.getPhases().add(appliedPhase);        foundUser.getJobs().add(jobEntityToSave);        JobEntity savedJobEntity = jobRepository.save(jobEntityToSave);        log.info("Job added successfully:[{}] to userId:[{}]", request, foundUser.getId());        return jobConverter.toResponse(savedJobEntity);    }    public Mono<ListJobs> getJobsByUserId(UUID userId) {        return userR2dbcRepository.findById(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException("User not found id:"+userId)))                .flatMap(user -> Flux.fromIterable(user.getJobs())                                .collectList()                                .map(jobConverter::toResponse));    }    @Transactional(readOnly = true)    public JobEntity getJobByUserAndJobId(UUID userId, UUID jobId) {        var foundUser = userRepository.findById(userId)            .orElseThrow(() -> new UserNotFoundException("User not found"));        return foundUser.getJobs().stream()            .filter(job -> job.getId().equals(jobId))            .findFirst()            .orElseThrow(() -> new JobNotFoundException("Job not found for user"));    }    @Transactional    public ContactPersonResponse addContactPerson(UUID userId, UUID jobId, ContactPersonRequest request) {        if (StringUtils.isBlank(request.getFirstName())) {            throw new IllegalArgumentException("Contact first name can not be empty");        }        var jobEntity = getJobByUserAndJobId(userId, jobId);        var contactPerson = jobEntity.getContactPerson();        if (contactPerson == null) {            contactPerson = new ContactPersonEntity();            contactPerson.setJob(jobEntity);        }        contactPerson.setFirstName(request.getFirstName());        if (StringUtils.isNotBlank(request.getLastName())) {            contactPerson.setLastName(request.getLastName());        }        if (StringUtils.isNotBlank(request.getEmail())) {            contactPerson.setEmail(request.getEmail());        }        if (StringUtils.isNotBlank(request.getPhone())) {            contactPerson.setPhone(request.getPhone());        }        if (StringUtils.isNotBlank(request.getLinkedin())) {            contactPerson.setLinkedin(request.getLinkedin());        }        jobEntity.setContactPerson(contactPerson);        var savedJobEntity = jobRepository.save(jobEntity);        log.info("Added/Updated contact person for jobId:{} userId:{}", jobId, userId);        return jobConverter.toContactPersonResponse(savedJobEntity);    }    @Transactional    public void addJobNote(UUID userId, UUID jobId, JobNoteRequest request) {        var jobEntity = getJobByUserAndJobId(userId, jobId);        jobEntity.setNotes(request.getNotes());        jobRepository.save(jobEntity);        log.info("Added job note for jobId:{} userId:{}", jobId, userId);    }}