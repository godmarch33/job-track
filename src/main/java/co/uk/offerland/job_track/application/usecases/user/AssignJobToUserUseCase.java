package co.uk.offerland.job_track.application.usecases.user;import co.uk.offerland.job_track.application.dto.user.*;import co.uk.offerland.job_track.domain.entity.JobPhase;import co.uk.offerland.job_track.domain.entity.PhaseStatus;import co.uk.offerland.job_track.domain.entity.PhaseSubStatus;import co.uk.offerland.job_track.domain.entity.nosql.Job;import co.uk.offerland.job_track.domain.entity.nosql.Phase;import co.uk.offerland.job_track.infrastructure.converter.JobConverter;import co.uk.offerland.job_track.infrastructure.exception.JobAlreadyExistsException;import co.uk.offerland.job_track.infrastructure.exception.UserNotFoundException;import co.uk.offerland.job_track.infrastructure.persistence.UserRepository;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Service;import reactor.core.publisher.Mono;import reactor.core.scheduler.Schedulers;import java.time.Instant;import java.util.UUID;@Slf4j@Service@RequiredArgsConstructorpublic class AssignJobToUserUseCase {    private final UserRepository userRepository;    private final JobConverter jobConverter;    public Mono<CreateJobResponse> addJob(UUID userId, CreateJobRequest request) {        return userRepository.findByUserId(userId)                .subscribeOn(Schedulers.boundedElastic())                .switchIfEmpty(Mono.error(new UserNotFoundException("User not found id:" + userId)))                .flatMap(foundUser -> Mono.just(foundUser)                        .flatMap(user -> {                            if (user.getJobs().stream().anyMatch(job -> job.getJobUrl().equals(request.getJobUrl()))) {                                return Mono.error(new JobAlreadyExistsException(                                        String.format("Job entity already exists, link: [%s], userId: [%s]", request.getJobUrl(), userId)));                            }                            return Mono.just(user);                        }))                .flatMap(foundUser -> {                    String jobSalary = request.getJobSalary();                    log.info("Job salary: " + jobSalary);                    Job newJobEntity = jobConverter.toEntity(request, Instant.now());                    foundUser.getJobs().add(newJobEntity);                    newJobEntity.addPhase(createSavedPhase());                    newJobEntity.addPhase(createAppliedPhase());                    foundUser.getInterviewStat().increaseSavedAndProgress();                    return userRepository.save(foundUser)                            .map(user -> jobConverter.toResponse(newJobEntity));                }).onErrorResume(JobAlreadyExistsException.class, Mono::error);    }    private Phase createAppliedPhase() {        var appliedPhase = new Phase();        appliedPhase.setStatus(PhaseStatus.IN_PROGRESS);        appliedPhase.setPhaseName(JobPhase.APPLIED.getLabel());        appliedPhase.setOrderIndex(2);        appliedPhase.setLastUpdatedDate(Instant.now());        appliedPhase.setSubStatus(PhaseSubStatus.ACTION_REQUIRED);        return appliedPhase;    }    private Phase createSavedPhase() {        var savedPhase = new Phase();        savedPhase.setStatus(PhaseStatus.COMPLETED);        savedPhase.setPhaseName(JobPhase.SAVED.getLabel());        savedPhase.setOrderIndex(1);        savedPhase.setLastUpdatedDate(Instant.now());        savedPhase.setSubStatus(PhaseSubStatus.DONE);        return savedPhase;    }    public Mono<ListJobs> getJobsByUserId(UUID userId) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException("User not found id:" + userId)))                .flatMap(user -> {                    user.getInterviewStat().getDailyProgress().releaseNextDayCounter();                    return userRepository.save(user);                })                .map(jobConverter::toJobsResponse)                .onErrorResume(UserNotFoundException.class, Mono::error);    }//    public Mono<JobEntity> getJobByUserAndJobId(UUID userId, UUID jobId) {//        return userRepository.findByUserIdAndJobsJobId(userId, jobId)//                .switchIfEmpty(Mono.error(new UserNotFoundException("User not found id:" + userId)))//                .flatMap(user -> user.getJobs().stream()//                        .filter(job -> job.getJobId().equals(jobId))//                        .findFirst()//                        .map(Mono::just)//                        .orElse(Mono.empty()));//    }    public ContactPersonResponse addContactPerson(UUID userId, UUID jobId, ContactPersonRequest request) {//        if (StringUtils.isBlank(request.getFirstName())) {//            throw new IllegalArgumentException("Contact first name can not be empty");//        }////        var jobEntity = getJobByUserAndJobId(userId, jobId);//        var contactPerson = jobEntity.getContactPerson();////        if (contactPerson == null) {//            contactPerson = new ContactPersonEntity();//            contactPerson.setJob(jobEntity);//        }////        contactPerson.setFirstName(request.getFirstName());//        if (StringUtils.isNotBlank(request.getLastName())) {//            contactPerson.setLastName(request.getLastName());//        }//        if (StringUtils.isNotBlank(request.getEmail())) {//            contactPerson.setEmail(request.getEmail());//        }//        if (StringUtils.isNotBlank(request.getPhone())) {//            contactPerson.setPhone(request.getPhone());//        }//        if (StringUtils.isNotBlank(request.getLinkedin())) {//            contactPerson.setLinkedin(request.getLinkedin());//        }////        jobEntity.setContactPerson(contactPerson);////        var savedJobEntity = jobRepository.save(jobEntity);//        log.info("Added/Updated contact person for jobId:{} userId:{}", jobId, userId);//////        return jobConverter.toContactPersonResponse(savedJobEntity);        return null;    }//    public Mono<Void> addJobNote(UUID userId, UUID jobId, JobNoteRequest request) {//        return userRepository.findByUserIdAndJobsJobId(userId, jobId)//                .switchIfEmpty(Mono.error(new JobNotFoundException("Job not found id:" + jobId)))//                .flatMap(user -> {//                    user.getJobs().stream()//                            .filter(job -> job.getJobId().equals(jobId))//                            .findFirst()//                            .ifPresent(job -> job.setNotes(request.getNotes())); // Update notes////                    return userRepository.save(user).then(); // Save the updated user//                })//                .doOnSuccess(v -> log.info("Added job note for jobId:{} userId:{}", jobId, userId));//    }}