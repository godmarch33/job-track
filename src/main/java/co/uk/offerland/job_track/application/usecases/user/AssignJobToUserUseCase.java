package co.uk.offerland.job_track.application.usecases.user;import co.uk.offerland.job_track.application.dto.phase.InterviewNoteResponse;import co.uk.offerland.job_track.application.dto.user.*;import co.uk.offerland.job_track.domain.entity.ContactPerson;import co.uk.offerland.job_track.domain.entity.JobPhase;import co.uk.offerland.job_track.domain.entity.PhaseStatus;import co.uk.offerland.job_track.domain.entity.PhaseSubStatus;import co.uk.offerland.job_track.domain.entity.nosql.*;import co.uk.offerland.job_track.infrastructure.converter.JobConverter;import co.uk.offerland.job_track.infrastructure.exception.JobAlreadyExistsException;import co.uk.offerland.job_track.infrastructure.exception.JobNotFoundException;import co.uk.offerland.job_track.infrastructure.exception.UserNotFoundException;import co.uk.offerland.job_track.infrastructure.persistence.UserRepository;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.tuple.Pair;import org.springframework.stereotype.Service;import reactor.core.publisher.Mono;import java.time.Instant;import java.util.UUID;import static co.uk.offerland.job_track.application.usecases.phase.handlers.AppliedPhaseHandler.*;import static org.apache.commons.lang3.tuple.Pair.*;@Slf4j@Service@RequiredArgsConstructorpublic class AssignJobToUserUseCase {    private final UserRepository userRepository;    private final JobConverter jobConverter;    public Mono<CreateJobResponse> addJob(UUID userId, CreateJobRequest request) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException(userId.toString())))                .flatMap(foundUser -> Mono.just(foundUser)                        .flatMap(user -> {                            if (user.getJobs().stream().anyMatch(job -> job.getJobUrl().equals(request.getJobUrl()))) {                                return Mono.error(new JobAlreadyExistsException(userId.toString(), request.getJobUrl()));                            }                            return Mono.just(user);                        }))                .flatMap(foundUser -> {                    Job newJobEntity = jobConverter.toEntity(request, Instant.now());                    foundUser.getJobs().add(newJobEntity);                    foundUser.getInterviewStat().getDailyProgress().updateCounter();                    if (request.getPhase().equals(JobPhase.APPLIED.getLabel())) {                        newJobEntity.addPhase(createSavedPhase(PhaseStatus.COMPLETED, PhaseSubStatus.DONE));                        newJobEntity.addPhase(createAppliedPhase(PhaseStatus.IN_PROGRESS, PhaseSubStatus.PENDING_HR_REPLY, PROCEED_TO_NEXT_INTERVIEW_STAGE, MSG_TOOLTIP_WAIT_RESPONSE));                    } else {                        newJobEntity.addPhase(createSavedPhase(PhaseStatus.COMPLETED, PhaseSubStatus.DONE));                        newJobEntity.addPhase(createAppliedPhase(PhaseStatus.IN_PROGRESS, PhaseSubStatus.ACTION_REQUIRED, MARK_AS_APPLIED, MARK_AS_APPLIED_TOOLTIP));                    }                    return userRepository.save(foundUser)                            .map(user -> jobConverter.toResponse(newJobEntity));                });    }    public Mono<ListJobs> getJobsByUserId(UUID userId) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException("User not found id:" + userId)))                .flatMap(user -> {                    user.getInterviewStat().getDailyProgress().releaseNextDayCounter();                    return userRepository.save(user);                })                .map(jobConverter::toJobsResponse)                .onErrorResume(UserNotFoundException.class, Mono::error);    }    public Mono<Pair<User, Job>> findUserByIdAndJobId(UUID userId, UUID jobId) {        return userRepository.findByUserId(userId)                .switchIfEmpty(Mono.error(new UserNotFoundException(userId.toString())))                .flatMap(user -> Mono.justOrEmpty(user.getJobs().stream()                                .filter(job -> job.getJobId().equals(jobId))                                .findFirst())                        .switchIfEmpty(Mono.error(new JobNotFoundException(userId.toString(), jobId.toString())))                        .map(job -> of(user, job)));    }    public Mono<ContactPersonResponse> addContactPerson(UUID userId, UUID jobId, ContactPersonRequest request) {        return findUserByIdAndJobId(userId, jobId)                .flatMap(result -> {                    Job job = result.getValue();                    var contactDetails = createContactDetails(request);                    job.getContactPersons().add(contactDetails);                    return userRepository.save(result.getKey())                            .thenReturn(jobConverter.toContactPersonResponse(contactDetails));                })                .doOnSuccess(v -> log.info("Added/Updated contact person for jobId:{} userId:{}", jobId, userId));    }    private Phase createAppliedPhase(PhaseStatus phaseStatus, PhaseSubStatus phaseSubStatus, String buttonName, String msgTooltip) {        var appliedPhase = new Phase();        var statusInfoEntity = new PhaseStatusInfoEntity();        statusInfoEntity.setStatus(phaseStatus);        statusInfoEntity.setSubStatus(phaseSubStatus);        statusInfoEntity.setNextStageButtonName(buttonName);        statusInfoEntity.setMsgTooltip(msgTooltip);        appliedPhase.setStatusInfoEntity(statusInfoEntity);        appliedPhase.setPhaseName(JobPhase.APPLIED.getLabel());        appliedPhase.setOrderIndex(2);        appliedPhase.setLastUpdatedDate(Instant.now());        return appliedPhase;    }    private Phase createSavedPhase(PhaseStatus phaseStatus, PhaseSubStatus subStatus) {        var savedPhase = new Phase();        var statusInfoEntity = new PhaseStatusInfoEntity();        statusInfoEntity.setStatus(phaseStatus);        statusInfoEntity.setSubStatus(subStatus);        statusInfoEntity.setNextStageButtonName("Save");        statusInfoEntity.setMsgTooltip("proceed to applied");        savedPhase.setStatusInfoEntity(statusInfoEntity);        savedPhase.setPhaseName(JobPhase.SAVED.getLabel());        savedPhase.setOrderIndex(1);        savedPhase.setLastUpdatedDate(Instant.now());        return savedPhase;    }    private ContactPerson createContactDetails(ContactPersonRequest request) {        return ContactPerson.builder()                .communicationChannel(request.getCommunicationChannel())                .linkedin(request.getLinkedin())                .phone(request.getPhone())                .email(request.getEmail())                .fullName(request.getFullName())                .build();    }    public Mono<InterviewNoteResponse> addInterviewNote(UUID userId, UUID jobId, JobNoteRequest request) {        return findUserByIdAndJobId(userId, jobId)                .flatMap(result -> {                    var job = result.getValue();                    InterviewNote notes = new InterviewNote(request.getNotes());                    job.setNotes(notes);                    return userRepository.save(result.getKey())                            .map(user -> new InterviewNoteResponse(notes.getNotes()));                })                .doOnSuccess(v -> log.info("Added job note for jobId:[{}] userId:[{}]", jobId, userId));    }}